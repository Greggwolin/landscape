import { NextRequest, NextResponse } from 'next/server';
import { sql } from '@/lib/dms/db';
import { CreateFolderZ, UpdateFolderZ, FolderZ, FolderTreeNodeZ } from './schema';
import { z } from 'zod';

/**
 * GET /api/dms/folders
 * Returns folder tree with optional filtering
 */
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const flat = searchParams.get('flat') === 'true'; // Return flat list instead of tree
    const includeInactive = searchParams.get('include_inactive') === 'true';

    // Fetch all folders with conditional WHERE clause
    const folders = includeInactive
      ? await sql`
          SELECT
            folder_id,
            parent_id,
            name,
            path,
            sort_order,
            default_profile,
            is_active,
            created_at,
            updated_at,
            (SELECT COUNT(*) FROM landscape.core_doc_folder_link WHERE folder_id = f.folder_id) as doc_count
          FROM landscape.core_doc_folder f
          ORDER BY sort_order, name
        `
      : await sql`
          SELECT
            folder_id,
            parent_id,
            name,
            path,
            sort_order,
            default_profile,
            is_active,
            created_at,
            updated_at,
            (SELECT COUNT(*) FROM landscape.core_doc_folder_link WHERE folder_id = f.folder_id) as doc_count
          FROM landscape.core_doc_folder f
          WHERE is_active = true
          ORDER BY sort_order, name
        `;

    // If flat list requested, return as is
    if (flat) {
      return NextResponse.json({
        success: true,
        folders,
      });
    }

    // Build tree structure
    const folderMap = new Map();
    const rootFolders: any[] = [];

    // First pass: create map
    folders.forEach(folder => {
      folderMap.set(folder.folder_id, { ...folder, children: [] });
    });

    // Second pass: build tree
    folders.forEach(folder => {
      const node = folderMap.get(folder.folder_id);
      if (folder.parent_id === null) {
        rootFolders.push(node);
      } else {
        const parent = folderMap.get(folder.parent_id);
        if (parent) {
          parent.children.push(node);
        } else {
          // Parent doesn't exist or is inactive, treat as root
          rootFolders.push(node);
        }
      }
    });

    return NextResponse.json({
      success: true,
      tree: rootFolders,
      totalFolders: folders.length,
    });

  } catch (error) {
    console.error('Error fetching folders:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to fetch folders',
        details: error instanceof Error ? error.message : String(error)
      },
      { status: 500 }
    );
  }
}

/**
 * POST /api/dms/folders
 * Create new folder
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const data = CreateFolderZ.parse(body);

    // Validate parent exists if specified
    if (data.parent_id) {
      const parentCheck = await sql`
        SELECT folder_id FROM landscape.core_doc_folder
        WHERE folder_id = ${data.parent_id} AND is_active = true
      `;

      if (parentCheck.length === 0) {
        return NextResponse.json(
          { success: false, error: 'Parent folder not found' },
          { status: 404 }
        );
      }
    }

    // Insert folder (path is auto-generated by trigger)
    const folders = await sql`
      INSERT INTO landscape.core_doc_folder (
        name,
        parent_id,
        sort_order,
        default_profile
      ) VALUES (
        ${data.name},
        ${data.parent_id || null},
        ${data.sort_order},
        ${JSON.stringify(data.default_profile)}
      )
      RETURNING
        folder_id,
        parent_id,
        name,
        path,
        sort_order,
        default_profile,
        is_active,
        created_at,
        updated_at
    `;

    const folder = folders[0];

    return NextResponse.json({
      success: true,
      folder,
    }, { status: 201 });

  } catch (error) {
    console.error('Error creating folder:', error);

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        {
          success: false,
          error: 'Validation error',
          details: error.errors
        },
        { status: 400 }
      );
    }

    return NextResponse.json(
      {
        success: false,
        error: 'Failed to create folder',
        details: error instanceof Error ? error.message : String(error)
      },
      { status: 500 }
    );
  }
}

/**
 * PATCH /api/dms/folders
 * Update existing folder
 */
export async function PATCH(request: NextRequest) {
  try {
    const body = await request.json();
    const data = UpdateFolderZ.parse(body);

    // Check folder exists
    const folderCheck = await sql`
      SELECT folder_id FROM landscape.core_doc_folder
      WHERE folder_id = ${data.folder_id}
    `;

    if (folderCheck.length === 0) {
      return NextResponse.json(
        { success: false, error: 'Folder not found' },
        { status: 404 }
      );
    }

    // Validate parent exists if specified
    if (data.parent_id !== undefined && data.parent_id !== null) {
      // Prevent self-referencing
      if (data.parent_id === data.folder_id) {
        return NextResponse.json(
          { success: false, error: 'Folder cannot be its own parent' },
          { status: 400 }
        );
      }

      const parentCheck = await sql`
        SELECT folder_id FROM landscape.core_doc_folder
        WHERE folder_id = ${data.parent_id} AND is_active = true
      `;

      if (parentCheck.length === 0) {
        return NextResponse.json(
          { success: false, error: 'Parent folder not found' },
          { status: 404 }
        );
      }
    }

    // Build dynamic update using conditional fragments
    const setParts: string[] = [];

    if (data.name !== undefined) {
      setParts.push('name');
    }
    if (data.parent_id !== undefined) {
      setParts.push('parent_id');
    }
    if (data.sort_order !== undefined) {
      setParts.push('sort_order');
    }
    if (data.default_profile !== undefined) {
      setParts.push('default_profile');
    }
    if (data.is_active !== undefined) {
      setParts.push('is_active');
    }

    if (setParts.length === 0) {
      return NextResponse.json(
        { success: false, error: 'No fields to update' },
        { status: 400 }
      );
    }

    // Execute update with tagged template
    const folders = await sql`
      UPDATE landscape.core_doc_folder
      SET
        ${data.name !== undefined ? sql`name = ${data.name},` : sql``}
        ${data.parent_id !== undefined ? sql`parent_id = ${data.parent_id},` : sql``}
        ${data.sort_order !== undefined ? sql`sort_order = ${data.sort_order},` : sql``}
        ${data.default_profile !== undefined ? sql`default_profile = ${JSON.stringify(data.default_profile)},` : sql``}
        ${data.is_active !== undefined ? sql`is_active = ${data.is_active},` : sql``}
        updated_at = NOW()
      WHERE folder_id = ${data.folder_id}
      RETURNING
        folder_id,
        parent_id,
        name,
        path,
        sort_order,
        default_profile,
        is_active,
        created_at,
        updated_at
    `;

    const folder = folders[0];

    return NextResponse.json({
      success: true,
      folder,
    });

  } catch (error) {
    console.error('Error updating folder:', error);

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        {
          success: false,
          error: 'Validation error',
          details: error.errors
        },
        { status: 400 }
      );
    }

    return NextResponse.json(
      {
        success: false,
        error: 'Failed to update folder',
        details: error instanceof Error ? error.message : String(error)
      },
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/dms/folders/:id
 * Soft delete folder (sets is_active = false)
 */
export async function DELETE(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const folderId = searchParams.get('folder_id');

    if (!folderId) {
      return NextResponse.json(
        { success: false, error: 'folder_id is required' },
        { status: 400 }
      );
    }

    // Check if folder has children
    const childrenCheck = await sql`
      SELECT COUNT(*) as count
      FROM landscape.core_doc_folder
      WHERE parent_id = ${folderId} AND is_active = true
    `;

    if (parseInt(childrenCheck[0].count) > 0) {
      return NextResponse.json(
        { success: false, error: 'Cannot delete folder with active children' },
        { status: 400 }
      );
    }

    // Soft delete
    const result = await sql`
      UPDATE landscape.core_doc_folder
      SET is_active = false, updated_at = NOW()
      WHERE folder_id = ${folderId}
      RETURNING folder_id
    `;

    if (result.length === 0) {
      return NextResponse.json(
        { success: false, error: 'Folder not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      folder_id: parseInt(folderId),
    });

  } catch (error) {
    console.error('Error deleting folder:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to delete folder',
        details: error instanceof Error ? error.message : String(error)
      },
      { status: 500 }
    );
  }
}
