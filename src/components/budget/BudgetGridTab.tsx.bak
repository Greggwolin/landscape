// v1.5 · 2025-11-07 · Added area/phase filters
'use client';

import { useState, useEffect, useMemo } from 'react';
import {
  CCard,
  CCardBody,
  CModal,
  CModalBody,
  CModalFooter,
  CModalHeader,
  CModalTitle,
} from '@coreui/react';
import { type BudgetMode } from './ModeSelector';
import BudgetDataGrid from './BudgetDataGrid';
import FiltersAccordion from './FiltersAccordion';
import { useBudgetData } from './hooks/useBudgetData';
import type { BudgetItem } from './ColumnDefinitions';
import BudgetItemModalV2, { type BudgetItemFormValues } from './BudgetItemModalV2';
// Removed: TimelineTab and SalesContent imports - tabs removed
import QuickAddCategoryModal from './QuickAddCategoryModal';
import IncompleteCategoriesReminder from './IncompleteCategoriesReminder';
import { useContainers } from '@/hooks/useContainers';
import { LAND_DEVELOPMENT_SUBTYPES } from '@/types/project-taxonomy';
import type { BudgetCategory, QuickAddCategoryResponse } from '@/types/budget-categories';
import { usePreference } from '@/hooks/useUserPreferences';
import { useProjectInflationSettings } from '@/hooks/useInflationSettings';
import { SemanticButton } from '@/components/ui/landscape';

interface Props {
  projectId: number;
  scopeFilter?: string; // Optional scope filter (e.g., "Planning & Engineering", "Development")
}

// Removed: SubTab type and tab navigation - now showing grid directly

// Helper to check if project is Land Development type
function isLandDevelopmentProject(projectTypeCode?: string): boolean {
  if (!projectTypeCode) return false;
  // Check if the project type code matches any Land Development subtype
  return LAND_DEVELOPMENT_SUBTYPES.some(
    subtype => projectTypeCode.toUpperCase() === subtype.toUpperCase()
  );
}

export default function BudgetGridTab({ projectId, scopeFilter }: Props) {
  // Removed: activeSubTab state - now showing grid directly

  // Mode state with database persistence via usePreference hook
  const [mode, setMode] = usePreference<BudgetMode>({
    key: 'budget.mode',
    defaultValue: 'napkin',
    scopeType: 'project',
    scopeId: projectId,
    migrateFrom: `budget_mode_${projectId}`, // Auto-migrate from old localStorage key
  });

  const [selected, setSelected] = useState<BudgetItem | undefined>();
  const [projectTypeCode, setProjectTypeCode] = useState<string | undefined>(undefined);

  const filterStorageKey = `budget_filters_${projectId}`;
  const getStoredFilters = () => {
    if (typeof window === 'undefined') return null;
    try {
      const raw = window.localStorage.getItem(filterStorageKey);
      return raw ? JSON.parse(raw) : null;
    } catch {
      return null;
    }
  };

  // Container filtering state
  const [selectedAreaIds, setSelectedAreaIds] = useState<number[]>(() => getStoredFilters()?.areas ?? []);
  const [selectedPhaseIds, setSelectedPhaseIds] = useState<number[]>(() => getStoredFilters()?.phases ?? []);
  const [includeProjectLevel, setIncludeProjectLevel] = useState<boolean>(() => {
    const stored = getStoredFilters();
    return stored?.includeProjectLevel ?? true;
  });

  useEffect(() => {
    const stored = getStoredFilters();
    setSelectedAreaIds(stored?.areas ?? []);
    setSelectedPhaseIds(stored?.phases ?? []);
    setIncludeProjectLevel(stored?.includeProjectLevel ?? true);
  }, [projectId]);

  useEffect(() => {
    if (typeof window === 'undefined') return;
    const payload = {
      areas: selectedAreaIds,
      phases: selectedPhaseIds,
      includeProjectLevel,
    };
    try {
      window.localStorage.setItem(filterStorageKey, JSON.stringify(payload));
    } catch (err) {
      console.warn('Unable to persist budget filters', err);
    }
  }, [selectedAreaIds, selectedPhaseIds, includeProjectLevel, filterStorageKey]);

  const {
    data: rawData,
    loading,
    error,
    hasFrontFeet,
    updateItem,
    createItem,
    deleteItem,
    refetch,
  } = useBudgetData(projectId);

  // Get container hierarchy for filtering
  const { phases } = useContainers({ projectId, includeCosts: false });

  // Get project-level cost inflation rate for escalation calculations
  const { data: inflationData } = useProjectInflationSettings(projectId);
  const costInflationRate = inflationData?.cost_inflation?.current_rate ?? undefined;

  const projectLevelCount = useMemo(
    () => rawData.filter(item => !item.division_id).length,
    [rawData]
  );

  // Filter budget data by selected containers and scope
  const data = useMemo(() => {
    const containerFilterActive = selectedAreaIds.length > 0 || selectedPhaseIds.length > 0;

    const divisionIds = new Set<number>();
    selectedAreaIds.forEach(id => divisionIds.add(id));
    selectedPhaseIds.forEach(id => divisionIds.add(id));

    if (selectedAreaIds.length > 0 && selectedPhaseIds.length === 0) {
      phases
        .filter(phase => selectedAreaIds.includes(phase.parent_id!))
        .forEach(phase => divisionIds.add(phase.division_id));
    }

    return rawData.filter(item => {
      // Apply scope filter if provided (check both scope and activity fields)
      if (scopeFilter && item.activity !== scopeFilter && item.scope !== scopeFilter) {
        return false;
      }

      // Apply container filters
      if (!item.division_id) {
        return includeProjectLevel;
      }
      if (!containerFilterActive) {
        return true;
      }
      return divisionIds.has(item.division_id);
    });
  }, [rawData, selectedAreaIds, selectedPhaseIds, phases, includeProjectLevel, scopeFilter]);

  const [modalState, setModalState] = useState<{
    open: boolean;
    mode: 'create' | 'edit';
    item?: BudgetItem | null;
    initialValues?: Partial<BudgetItemFormValues>;
  }>({ open: false, mode: 'create', item: undefined, initialValues: undefined });
  const [pendingDelete, setPendingDelete] = useState<BudgetItem | null>(null);

  const activeContainerContext = useMemo(() => {
    if (selectedPhaseIds.length === 1) {
      return selectedPhaseIds[0];
    }
    if (selectedAreaIds.length === 1 && selectedPhaseIds.length === 0) {
      return selectedAreaIds[0];
    }
    return null;
  }, [selectedAreaIds, selectedPhaseIds]);

  // Quick-add category modal state
  const [quickAddCategoryOpen, setQuickAddCategoryOpen] = useState(false);
  const [availableCategories, setAvailableCategories] = useState<BudgetCategory[]>([]);

  const handleProjectLevelToggle = (value: boolean) => {
    setIncludeProjectLevel(value);
  };

  const handleAddFromRow = (item: BudgetItem) => {
    openCreateModalWithDefaults({
      division_id: item.division_id ?? null,
      category_l1_id: item.category_l1_id ?? null,
      category_l2_id: item.category_l2_id ?? null,
      category_l3_id: item.category_l3_id ?? null,
      category_l4_id: item.category_l4_id ?? null,
    });
  };

  const handleGroupAdd = (context: { level: number; pathIds: number[]; pathNames: string[] }) => {
    openCreateModalWithDefaults({
      division_id: activeContainerContext ?? null,
      category_l1_id: context.pathIds[0] ?? null,
      category_l2_id: context.pathIds[1] ?? null,
      category_l3_id: context.pathIds[2] ?? null,
      category_l4_id: context.pathIds[3] ?? null,
    });
  };

  const handleRequestDelete = (item: BudgetItem) => {
    setPendingDelete(item);
  };

  const handleConfirmDelete = async () => {
    if (!pendingDelete) return;
    try {
      await deleteItem(pendingDelete.fact_id);
      if (selected?.fact_id === pendingDelete.fact_id) {
        setSelected(undefined);
      }
    } catch (err) {
      console.error('Failed to delete budget item', err);
      alert(err instanceof Error ? err.message : 'Failed to delete budget item, please try again.');
    } finally {
      setPendingDelete(null);
    }
  };

  const handleCancelDelete = () => setPendingDelete(null);

  // Container filter handlers
  const handleAreaSelect = (areaId: number | null) => {
    if (areaId === null) {
      setSelectedAreaIds([]);
      setSelectedPhaseIds([]);
    } else {
      setSelectedAreaIds((prev) =>
        prev.includes(areaId)
          ? prev.filter((id) => id !== areaId)
          : [...prev, areaId]
      );
    }
  };

  const handlePhaseSelect = (phaseId: number | null) => {
    if (phaseId === null) {
      setSelectedPhaseIds([]);
    } else {
      setSelectedPhaseIds((prev) =>
        prev.includes(phaseId)
          ? prev.filter((id) => id !== phaseId)
          : [...prev, phaseId]
      );
    }
  };

  const handleClearFilters = () => {
    setSelectedAreaIds([]);
    setSelectedPhaseIds([]);
  };

  // Note: QuickAddCategoryModal fetches its own categories from /api/budget/categories if needed
  // The legacy /api/financial/budget-categories endpoint has been deprecated

  useEffect(() => {
    const fetchProjectMetadata = async () => {
      try {
        const response = await fetch(`/api/projects/${projectId}`);
        if (!response.ok) return;
        const payload = await response.json();
        const code =
          payload?.project?.project_type_code ??
          payload?.project?.projectTypeCode ??
          payload?.project_type_code ??
          payload?.projectTypeCode;
        if (typeof code === 'string' && code.length > 0) {
          setProjectTypeCode(code.toUpperCase());
        }
      } catch (err) {
        console.error('Failed to load project metadata', err);
      }
    };

    void fetchProjectMetadata();
  }, [projectId]);

  const handleInlineCommit = async (
    item: BudgetItem,
    field: keyof BudgetItem,
    rawValue: unknown
  ) => {
    if (!item.fact_id) return;

    const editableFields: Array<keyof BudgetItem> = [
      'qty',
      'rate',
      'uom_code',
      'notes',
      'division_id',
      'activity',
      'start_period',
      'periods_to_complete',
      'start_date',
      'end_date',
      'vendor_name',
      'escalation_rate',
      'escalation_method',
      'contingency_pct',
      'timing_method',
      'curve_profile',
      'curve_steepness',
      'funding_id',
      'curve_id',
      'milestone_id',
      'cf_start_flag',
      'category_l1_id',
      'category_l2_id',
      'category_l3_id',
      'category_l4_id',
    ];
    if (!editableFields.includes(field)) {
      return;
    }

    let value = rawValue;

    // Parse numeric fields
    if (field === 'qty' || field === 'rate' || field === 'start_period' || field === 'periods_to_complete') {
      value =
        rawValue === null || rawValue === undefined || rawValue === ''
          ? null
          : Number(rawValue);
    }

    if (field === 'notes' && typeof rawValue === 'string') {
      value = rawValue;
    }

    const patch: Partial<BudgetItem> = {
      [field]: value,
    };

    if (field === 'qty' || field === 'rate') {
      const qty =
        field === 'qty'
          ? (value as number | null) ?? 0
          : item.qty ?? 0;
      const rate =
        field === 'rate'
          ? (value as number | null) ?? 0
          : item.rate ?? 0;

      if (qty !== null && rate !== null) {
        patch.amount = Number(qty) * Number(rate);
      }
    }

    try {
      await updateItem(item.fact_id, patch);
    } catch (err) {
      console.error('Failed to save budget item', err);
      alert(
        err instanceof Error ? err.message : 'Failed to save budget item, please try again.'
      );
    }
  };

  const openCreateModalWithDefaults = (initialValues?: Partial<BudgetItemFormValues>) => {
    setModalState({ open: true, mode: 'create', item: undefined, initialValues });
  };

  const openCreateModal = () => {
    openCreateModalWithDefaults();
  };

  const openEditModal = (item: BudgetItem) => {
    setSelected(item);
    setModalState({ open: true, mode: 'edit', item, initialValues: undefined });
  };

  const closeModal = () =>
    setModalState((prev) => ({ ...prev, open: false, initialValues: undefined }));

  const handleModalSave = async (values: BudgetItemFormValues) => {
    if (modalState.mode === 'create') {
      await createItem({
        project_id: projectId,
        category_l1_id: values.category_l1_id ?? null,
        category_l2_id: values.category_l2_id ?? null,
        category_l3_id: values.category_l3_id ?? null,
        category_l4_id: values.category_l4_id ?? null,
        division_id: values.division_id ?? null,
        scope: scopeFilter ?? values.scope ?? null, // Use scopeFilter if provided
        activity: scopeFilter ?? values.activity ?? null, // Also set activity field
        qty: values.qty,
        rate: values.rate,
        amount: values.amount,
        start_period: values.start_period ?? null,
        periods: values.periods ?? null,
        vendor_name: values.vendor_name ?? null,
        notes: values.notes,
        uom_code: values.uom_code,
        escalation_rate: values.escalation_rate ?? null,
        contingency_pct: values.contingency_pct ?? null,
        timing_method: values.timing_method ?? null,
        funding_id: values.funding_id ?? null,
        curve_id: values.curve_id ?? null,
        milestone_id: values.milestone_id ?? null,
        cf_start_flag: values.cf_start_flag ?? null,
        start_date: values.start_date ?? null,
        end_date: values.end_date ?? null,
      });
    } else if (modalState.item) {
      const patch: Partial<BudgetItem> = {
        qty: values.qty,
        rate: values.rate,
        amount: values.amount,
        start_period: values.start_period ?? null,
        periods_to_complete: values.periods ?? null,
        vendor_name: values.vendor_name ?? null,
        notes: values.notes,
        uom_code: values.uom_code,
        escalation_rate: values.escalation_rate ?? null,
        contingency_pct: values.contingency_pct ?? null,
        timing_method: values.timing_method ?? null,
        funding_id: values.funding_id ?? null,
        curve_id: values.curve_id ?? null,
        milestone_id: values.milestone_id ?? null,
        cf_start_flag: values.cf_start_flag ?? null,
        start_date: values.start_date ?? null,
        end_date: values.end_date ?? null,
      };

      await updateItem(modalState.item.fact_id, patch);
      setSelected((prev) =>
        prev && modalState.item && prev.fact_id === modalState.item.fact_id
          ? ({
              ...prev,
              ...patch,
            } as BudgetItem)
          : prev
      );
    }
  };

  const handleModalDelete = async () => {
    if (!modalState.item) return;
    await deleteItem(modalState.item.fact_id);
    if (selected?.fact_id === modalState.item.fact_id) {
      setSelected(undefined);
    }
  };

  const handleQuickAddSuccess = (newCategory: QuickAddCategoryResponse) => {
    // Add new category to available categories
    setAvailableCategories((prev) => [...prev, newCategory]);
    // Could also auto-select this category in the grid if needed
  };

  if (loading) {
    return <div className="py-5 text-center text-secondary">Loading budget data…</div>;
  }

  if (error) {
    return <div className="alert alert-danger">Error loading budget data: {String(error)}</div>;
  }

  return (
    <CCard>
      <CCardBody>
        {/* Scope Label - shown when filtering by scope */}
        {scopeFilter && (
          <div className="mb-3 pb-2 border-bottom" style={{ borderColor: 'var(--cui-border-color)' }}>
            <h4 className="mb-0" style={{ color: 'var(--cui-body-color)', fontSize: '1.25rem', fontWeight: 600 }}>
              Budget: {scopeFilter}
            </h4>
          </div>
        )}

        {/* Incomplete Categories Reminder */}
        <IncompleteCategoriesReminder projectId={projectId} className="mb-3" />

        {/* Filters Accordion */}
        <div className="mb-3">
          <FiltersAccordion
            projectId={projectId}
            selectedAreaIds={selectedAreaIds}
            selectedPhaseIds={selectedPhaseIds}
            onAreaSelect={handleAreaSelect}
            onPhaseSelect={handlePhaseSelect}
            onClearFilters={handleClearFilters}
            includeProjectLevel={includeProjectLevel}
            projectLevelItemCount={projectLevelCount}
            onProjectLevelToggle={handleProjectLevelToggle}
          />
        </div>

        {/* Action buttons - right aligned */}
        <div className="d-flex tw-justify-content-end tw-align-items-center mb-3 gap-2">
          <SemanticButton
            intent="secondary-action"
            size="sm"
            onClick={() => setQuickAddCategoryOpen(true)}
          >
            + Quick Add Category
          </SemanticButton>
          <SemanticButton intent="primary-action" size="sm" onClick={openCreateModal}>
            + Add Item
          </SemanticButton>
        </div>

        {/* Budget Grid - always full width now */}
        <BudgetDataGrid
          data={data}
          mode={mode}
          projectId={projectId}
          selectedItem={selected}
          onRowSelect={setSelected}
          onInlineCommit={handleInlineCommit}
          onOpenModal={mode === 'napkin' ? undefined : openEditModal}
          projectTypeCode={projectTypeCode}
          onRequestRowAdd={handleAddFromRow}
          onRequestRowDelete={handleRequestDelete}
          onRequestGroupAdd={handleGroupAdd}
          hasFrontFeet={hasFrontFeet}
          costInflationRate={costInflationRate}
        />

        <div className="small text-secondary mt-2">
          Showing {data.length} budget item{data.length !== 1 ? 's' : ''}
        </div>
      </CCardBody>

      <BudgetItemModalV2
        open={modalState.open}
        mode={modalState.mode}
        projectId={projectId}
        initialItem={modalState.item ?? null}
        initialFormValues={modalState.initialValues}
        activeBudgetMode={mode}
        onClose={closeModal}
        onSave={handleModalSave}
        onDelete={modalState.mode === 'edit' ? handleModalDelete : undefined}
      />

      {/* Quick Add Category Modal */}
      <QuickAddCategoryModal
        isOpen={quickAddCategoryOpen}
        onClose={() => setQuickAddCategoryOpen(false)}
        onSuccess={handleQuickAddSuccess}
        projectId={projectId}
        availableCategories={availableCategories}
      />

      <CModal visible={Boolean(pendingDelete)} onClose={handleCancelDelete}>
        <CModalHeader>
          <CModalTitle>Delete this budget item?</CModalTitle>
        </CModalHeader>
        <CModalBody>
          <p className="mb-1">
            {pendingDelete?.notes || '(No description)'}
          </p>
          <p className="text-muted small mb-0">
            This action cannot be undone.
          </p>
        </CModalBody>
        <CModalFooter>
          <SemanticButton intent="secondary-action" variant="outline" onClick={handleCancelDelete}>
            Cancel
          </SemanticButton>
          <SemanticButton intent="destructive-action" onClick={handleConfirmDelete}>
            Delete
          </SemanticButton>
        </CModalFooter>
      </CModal>
    </CCard>
  );
}
