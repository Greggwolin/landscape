/**
 * Land Use Pricing Table
 * Manages product-specific pricing assumptions with growth rates
 */

'use client';

import React, { useState, useMemo, useEffect, useRef, useCallback } from 'react';
import {
  useReactTable,
  getCoreRowModel,
  flexRender,
  type ColumnDef,
} from '@tanstack/react-table';
import { CBadge } from '@coreui/react';
import { useQueryClient } from '@tanstack/react-query';
import {
  usePricingAssumptions,
  useSavePricingAssumptions,
  useDeletePricingAssumption,
  useParcelProductTypes,
  useGrowthRateBenchmarks,
} from '@/hooks/useSalesAbsorption';
import { useMeasureOptions } from '@/hooks/useMeasures';
import { useProjectInflationSettings } from '@/hooks/useInflationSettings';
import type { PricingAssumption } from '@/types/sales-absorption';
import { formatMoney } from '@/utils/formatters/number';
import { Trash2, Plus, Save, X } from 'lucide-react';
import { SemanticButton } from '@/components/ui/landscape';
import './PricingTable.css';

interface Props {
  projectId: number;
  phaseFilters?: number[];
  mode?: 'napkin' | 'standard' | 'detail';
}

// Use-type pill colors aligned with Parcel Detail & Parcel Sales tables
const USE_TYPE_PILL_COLORS: Record<string, { bg: string; text: string }> = {
  // Blues
  SFD: { bg: '#1e3a8a', text: '#93c5fd' },   // blue-900 / blue-300
  VLDR: { bg: '#1e3a8a', text: '#93c5fd' },
  LDR: { bg: '#1e3a8a', text: '#93c5fd' },
  MLDR: { bg: '#1e3a8a', text: '#93c5fd' },
  MDR: { bg: '#1e3a8a', text: '#93c5fd' },
  RET: { bg: '#1e3a8a', text: '#93c5fd' },
  // Purples
  MX: { bg: '#581c87', text: '#d8b4fe' },    // purple-900 / purple-300
  MU: { bg: '#581c87', text: '#d8b4fe' },
  SFA: { bg: '#581c87', text: '#d8b4fe' },
  // Oranges
  MF: { bg: '#7c2d12', text: '#fdba74' },    // orange-900 / orange-300
  HDR: { bg: '#7c2d12', text: '#fdba74' },
  BTR: { bg: '#7c2d12', text: '#fdba74' },
  // Greens
  PARK: { bg: '#14532d', text: '#86efac' },  // green-900 / green-300
};

const getUseTypePillColors = (typeCode?: string | null) => {
  const key = (typeCode ?? '').toUpperCase();
  return USE_TYPE_PILL_COLORS[key] || { bg: '#312e81', text: '#a5b4fc' }; // indigo fallback
};

// Extracted component for editable price cell to avoid hooks-in-render-prop violation
function EditablePriceCell({
  value,
  onSave
}: {
  value: number | null;
  onSave: (newValue: number | null) => void;
}) {
  const [localValue, setLocalValue] = React.useState<string>('');
  const [isFocused, setIsFocused] = React.useState(false);

  // Sync from prop value when not actively editing
  React.useEffect(() => {
    if (!isFocused) {
      setLocalValue(value ? String(value) : '');
    }
  }, [value, isFocused]);

  // Format display value with currency formatting
  const getDisplayValue = () => {
    if (isFocused) {
      return localValue;
    }
    if (!value) return '';

    // Format as currency: show decimals only if value has them
    const numValue = Number(value);
    const hasDecimals = numValue % 1 !== 0;
    return numValue.toLocaleString('en-US', {
      minimumFractionDigits: hasDecimals ? 2 : 0,
      maximumFractionDigits: 2,
    });
  };

  const handleBlur = () => {
    setIsFocused(false);
    const numValue = localValue === '' ? null : parseFloat(localValue.replace(/,/g, ''));
    if (numValue !== value) {
      onSave(numValue);
    }
  };

  return (
    <div className="text-right px-2">
      <div className="tw-relative tw-inline-flex tw-items-center tw-w-full">
        <span className="tw-absolute left-2 tw-text-sm tw-pointer-events-none" style={{ color: 'var(--cui-secondary-color)' }}>$</span>
        <input
          type="text"
          inputMode="decimal"
          value={getDisplayValue()}
          onChange={(e) => setLocalValue(e.target.value)}
          onFocus={() => setIsFocused(true)}
          onBlur={handleBlur}
          style={{
            textAlign: 'right',
            paddingLeft: '1.5rem',
            width: '100%',
            borderColor: 'var(--cui-border-color)',
            backgroundColor: 'var(--cui-body-bg)',
            color: 'var(--cui-body-color)',
          }}
          className="border rounded px-2 py-1 tw-text-sm"
        />
      </div>
    </div>
  );
}

export default function PricingTable({ projectId, phaseFilters, mode = 'napkin' }: Props) {
  const queryClient = useQueryClient();
  const { data: assumptions, isLoading, error, refetch: refetchPricingAssumptions } = usePricingAssumptions(projectId);
  const { data: parcelProducts, isLoading: isLoadingProducts } = useParcelProductTypes(
    projectId,
    phaseFilters && phaseFilters.length > 0 ? phaseFilters : null
  );
  const { options: uomOptions, isLoading: isLoadingMeasures } = useMeasureOptions(true, 'land_pricing');
  const { data: growthRateBenchmarks } = useGrowthRateBenchmarks();
  const { data: inflationSettings } = useProjectInflationSettings(projectId);
  const saveMutation = useSavePricingAssumptions();
  const deleteMutation = useDeletePricingAssumption();

  const [editingRows, setEditingRows] = useState<PricingAssumption[]>([]);
  const [editingRowId, setEditingRowId] = useState<number | null>(null);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [customGrowthRate, setCustomGrowthRate] = useState<string>('');
  const [globalGrowthRate, setGlobalGrowthRate] = useState<number | null>(null); // No default - use admin configured options
  const [isCustomGrowthRate, setIsCustomGrowthRate] = useState(false);
  const lastInflationRate = useRef<number | null>(null);

  // Track which rows have been modified (dirty tracking)
  const [dirtyRowIndices, setDirtyRowIndices] = useState<Set<number>>(new Set());

  // Use API UOM options only - no fallback
  const uomChoices = uomOptions;

  // Build growth rate options from benchmarks
  const growthRateOptions = useMemo(() => {
    const options: Array<{ id: string; value: number; label: string; setId?: string; isMultiStep?: boolean }> = [];

    // Add benchmarks from API
    if (growthRateBenchmarks && Array.isArray(growthRateBenchmarks)) {
      growthRateBenchmarks.forEach((benchmark: any, index: number) => {
        let rate: number | null = null;
        let label = benchmark.set_name;
        let isMultiStep = false;

        if (benchmark.rate_type === 'flat' && benchmark.current_rate !== null) {
          // Use flat rate directly
          rate = Number(benchmark.current_rate);
        } else if (benchmark.rate_type === 'stepped' && benchmark.steps && benchmark.steps.length > 0) {
          // For stepped benchmarks, show it's a multi-step series
          // Calculate weighted average of all steps for display
          const totalPeriods = benchmark.steps.reduce((sum: number, step: any) => sum + (step.periods || 0), 0);
          const weightedSum = benchmark.steps.reduce((sum: number, step: any) => {
            return sum + (Number(step.rate) * (step.periods || 0));
          }, 0);
          rate = totalPeriods > 0 ? weightedSum / totalPeriods : Number(benchmark.steps[0].rate);

          // Show it's a multi-step series with step count
          label = `${benchmark.set_name} (${benchmark.steps.length} steps)`;
          isMultiStep = true;
        }

        if (rate !== null && !isNaN(rate)) {
          options.push({
            // Use set_id in the ID to ensure uniqueness
            id: `benchmark-${benchmark.set_id || index}`,
            value: rate,
            label: `${(rate * 100).toFixed(1)}% - ${label}`,
            setId: benchmark.set_id,
            isMultiStep,
          });
        }
      });
    }

    // If no benchmarks configured, return empty array - don't use fallback
    // This will show "No options configured" in the dropdown
    if (options.length === 0) {
      return [];
    }

    // Sort by value
    return options.sort((a, b) => a.value - b.value);
  }, [growthRateBenchmarks]);

  const formatOptionLabel = (opt: { value: number; label: string }) => {
    return `${(opt.value * 100).toFixed(1)}%`;
  };

  const applyBenchmarkRate = useCallback(async (newRate: number) => {
    console.log(`[PricingTable] Applying price inflation selection: ${newRate * 100}%`);
    setGlobalGrowthRate(newRate);
    setIsCustomGrowthRate(false);
    setIsSaving(true);
    try {
      console.log(`[PricingTable] Applying benchmark growth_rate ${newRate} to all pricing assumptions`);

      const response = await fetch(`/api/projects/${projectId}/pricing-assumptions/bulk-update-field/`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ field: 'growth_rate', value: newRate }),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to update growth rate');
      }

      const result = await response.json();
      console.log(`[PricingTable] Updated ${result.count} rows via benchmark selection`);

      setEditingRows(prev => prev.map(row => ({ ...row, growth_rate: newRate })));
      setDirtyRowIndices(new Set());

      await refetchPricingAssumptions();

      const typesCodes = [...new Set(editingRows.map(row => row.lu_type_code))];
      const typeCodesParam = typesCodes.join(',');

      const recalcResponse = await fetch(
        `/api/projects/${projectId}/recalculate-sfd/?type_codes=${typeCodesParam}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
        }
      );

      if (recalcResponse.ok) {
        const recalcResult = await recalcResponse.json();
        console.log(`[PricingTable] Recalculated ${recalcResult.updated_count} parcels after benchmark rate change`);

        await queryClient.invalidateQueries({
          queryKey: ['parcels-with-sales', projectId],
        });
      } else {
        console.error('[PricingTable] Recalculation failed:', await recalcResponse.text());
      }
    } catch (err) {
      alert(err instanceof Error ? err.message : 'Failed to save growth rate');
    } finally {
      setIsSaving(false);
    }
  }, [projectId, queryClient, refetchPricingAssumptions, editingRows]);

  // Initialize global growth from selected price inflation set if not set yet
  useEffect(() => {
    if (globalGrowthRate !== null) return;
    const selectedRate = inflationSettings?.price_inflation?.current_rate;
    if (selectedRate !== null && selectedRate !== undefined) {
      setGlobalGrowthRate(selectedRate);
      // Toggle custom flag if selection not in options
      const matchesOption = growthRateOptions.some(opt => Math.abs(opt.value - selectedRate) < 0.0001);
      setIsCustomGrowthRate(!matchesOption);
      if (!matchesOption) {
        setCustomGrowthRate((selectedRate * 100).toFixed(1));
      }
    }
  }, [inflationSettings?.price_inflation?.current_rate, globalGrowthRate, growthRateOptions]);

  // React when price inflation selection (nav) changes
  useEffect(() => {
    const rate = inflationSettings?.price_inflation?.current_rate;
    if (rate === null || rate === undefined) {
      console.log('[PricingTable] Nav price inflation not set; skipping');
      return;
    }
    if (lastInflationRate.current !== null && Math.abs(lastInflationRate.current - rate) < 1e-6) {
      return;
    }
    lastInflationRate.current = rate;
    console.log(`[PricingTable] Detected nav price inflation change to ${rate * 100}% (will apply to pricing assumptions)`);
    void applyBenchmarkRate(rate);
  }, [inflationSettings?.price_inflation?.current_rate, applyBenchmarkRate]);

  // Initialize editing rows: merge parcel products with existing pricing assumptions
  useEffect(() => {
    if (!parcelProducts) return;

    // Don't reset editing rows if user has unsaved changes
    if (hasUnsavedChanges) return;

    if (parcelProducts.length > 0) {
      // Create rows for each actual parcel product combination
      const rows: PricingAssumption[] = parcelProducts.map(product => {
        // Check if we have existing pricing for this type/product combo
        // Ensure assumptions is an array before calling .find()
        const existing = Array.isArray(assumptions) ? assumptions.find(
          a => a.lu_type_code === product.type_code &&
               (a.product_code || '') === (product.product_code || '')
        ) : undefined;

        if (existing) {
          // Use existing pricing data (with cleanup)
          return {
            ...existing,
            product_code: existing.product_code || '',
            // Keep existing growth_rate as-is, don't apply fallback
            growth_rate: existing.growth_rate ?? null,
          };
        } else {
          // Create new row without hardcoded defaults
          // User must select from admin-configured options
          return {
            project_id: projectId,
            lu_type_code: product.type_code,
            product_code: product.product_code || '',
            price_per_unit: 0,
            unit_of_measure: null, // No default - must be selected
            growth_rate: null,      // No default - must be selected
          };
        }
      });

      setEditingRows(rows);

      // Initialize global growth rate from the first row that has one
      const firstGrowthRate = rows.find(r => r.growth_rate != null)?.growth_rate;
      if (firstGrowthRate != null && globalGrowthRate === null) {
        setGlobalGrowthRate(firstGrowthRate);

        // Check if this rate matches any benchmark option (with tolerance)
        const matchesOption = growthRateOptions.some(opt =>
          Math.abs(opt.value - firstGrowthRate) < 0.0001
        );
        if (!matchesOption && firstGrowthRate !== 0) {
          // Set as custom rate if it doesn't match any option
          setIsCustomGrowthRate(true);
          setCustomGrowthRate((firstGrowthRate * 100).toFixed(1));
        }
      }

      // Don't auto-mark as unsaved on initial load
      setHasUnsavedChanges(false);
    } else {
      // Clear rows when no parcel products (e.g., filtered to nothing)
      setEditingRows([]);
      setHasUnsavedChanges(false);
    }
  }, [assumptions, parcelProducts, projectId, hasUnsavedChanges, globalGrowthRate, growthRateOptions]);

  const handleCellChange = React.useCallback((rowIndex: number, field: keyof PricingAssumption, value: any) => {
    setEditingRows(prev => {
      const updated = [...prev];
      updated[rowIndex] = { ...updated[rowIndex], [field]: value };
      return updated;
    });
    // Mark this row as dirty
    setDirtyRowIndices(prev => new Set(prev).add(rowIndex));
    // Defer setting unsaved changes to avoid immediate re-render during typing
    setTimeout(() => setHasUnsavedChanges(true), 0);
  }, []);

  // Auto-save handler for fields that should save immediately (like UOM dropdown)
  const handleCellChangeAndSave = React.useCallback(async (rowIndex: number, field: keyof PricingAssumption, value: any) => {
    // Update local state first
    const updatedRows = [...editingRows];
    updatedRows[rowIndex] = { ...updatedRows[rowIndex], [field]: value };
    setEditingRows(updatedRows);

    // Validate the row before saving
    const row = updatedRows[rowIndex];
    if (!row.lu_type_code || !row.unit_of_measure) {
      // Don't auto-save if required fields are missing
      setDirtyRowIndices(prev => new Set(prev).add(rowIndex));
      setHasUnsavedChanges(true);
      return;
    }

    // Auto-save ONLY this changed row
    setIsSaving(true);
    try {
      await saveMutation.mutateAsync({
        projectId,
        assumptions: [updatedRows[rowIndex]], // Only save the changed row
      });
      // Clear this row from dirty set
      setDirtyRowIndices(prev => {
        const next = new Set(prev);
        next.delete(rowIndex);
        return next;
      });
      setHasUnsavedChanges(false);
      setEditingRowId(null);
    } catch (err) {
      console.error('Failed to auto-save:', err);
      setHasUnsavedChanges(true);
    } finally {
      setIsSaving(false);
    }
  }, [editingRows, saveMutation, projectId]);

  const handleAddRow = () => {
    const newRow: PricingAssumption = {
      project_id: projectId,
      lu_type_code: '',
      product_code: '',
      price_per_unit: 0,
      unit_of_measure: null, // No default - must be selected from admin options
      growth_rate: null,      // No default - must be selected from admin options
    };
    setEditingRows(prev => [...prev, newRow]);
    setHasUnsavedChanges(true);
  };

  const handleDeleteRow = async (rowIndex: number) => {
    const row = editingRows[rowIndex];

    if (row.id) {
      // Confirm deletion
      if (!confirm(`Delete pricing for ${row.lu_type_code} - ${row.product_code}?`)) {
        return;
      }

      try {
        await deleteMutation.mutateAsync({ projectId, id: row.id });
        setEditingRows(prev => prev.filter((_, i) => i !== rowIndex));
      } catch (err) {
        alert('Failed to delete pricing assumption');
      }
    } else {
      // Just remove from local state (not saved yet)
      setEditingRows(prev => prev.filter((_, i) => i !== rowIndex));
    }
    setHasUnsavedChanges(true);
  };

  const handleSave = async () => {
    // Get only the dirty (changed) rows
    const dirtyRows = Array.from(dirtyRowIndices)
      .map(index => editingRows[index])
      .filter(row => row); // Filter out undefined

    if (dirtyRows.length === 0) {
      // Nothing to save
      setHasUnsavedChanges(false);
      return;
    }

    // Validate dirty rows
    const invalidRows = dirtyRows.filter(
      row => !row.lu_type_code || row.price_per_unit <= 0 || !row.unit_of_measure
    );

    if (invalidRows.length > 0) {
      alert('Please fill in all required fields (Use Type, Price > 0, UOM) before saving.');
      return;
    }

    setIsSaving(true);
    try {
      await saveMutation.mutateAsync({
        projectId,
        assumptions: dirtyRows, // Only save dirty rows
      });
      // Clear dirty tracking
      setDirtyRowIndices(new Set());
      setHasUnsavedChanges(false);
      setEditingRowId(null);
      // Success toast would go here
    } catch (err) {
      alert('Failed to save pricing assumptions');
    } finally {
      setIsSaving(false);
    }
  };

  const handleCancel = () => {
    if (hasUnsavedChanges && !confirm('Discard unsaved changes?')) {
      return;
    }
    // Reset to original data
    window.location.reload();
  };

  const columns = useMemo<ColumnDef<PricingAssumption>[]>(
    () => {
      const baseColumns: ColumnDef<PricingAssumption>[] = [];

      // Add Family column in Napkin/Standard modes only (Detail mode shows Growth Rate instead)
      if (mode !== 'detail') {
        baseColumns.push({
          accessorKey: 'family_name',
          header: () => <div className="text-center">Family</div>,
          size: 100,
          cell: ({ row }) => {
            const product = parcelProducts?.find(
              p => p.type_code === row.original.lu_type_code &&
                   (p.product_code || '') === (row.original.product_code || '')
            );
            const familyName = product?.family_name;

            if (!familyName) {
              return <div className="text-center tw-text-xs" style={{ color: 'var(--cui-secondary-color)' }}>-</div>;
            }

            return (
              <div className="text-center tw-text-sm" style={{ color: 'var(--cui-body-color)' }}>
                {familyName}
              </div>
            );
          },
        });
      }

      // Use Type column
      baseColumns.push({
        accessorKey: 'lu_type_code',
        header: () => <div className="text-center">Use<br />Type</div>,
        size: 100,
        cell: ({ row }) => {
          const value = row.original.lu_type_code;
          const rowIndex = row.index;
          const isEditing = editingRowId === rowIndex;

          // Match ParcelSalesTable pill colors
          const { bg, text } = getUseTypePillColors(value);

          return (
            <div className="text-center">
              <span
                className="px-2 py-1 rounded tw-text-xs fw-semibold"
                style={{
                  backgroundColor: bg,
                  color: text,
                  letterSpacing: '0.01em',
                }}
              >
                {value || 'N/A'}
              </span>
            </div>
          );
        },
      });

      baseColumns.push({
        accessorKey: 'product_code',
        header: 'Product',
        size: 140,
        cell: ({ row }) => {
          const value = row.original.product_code;
          return (
            <div className="text-left px-2">
              {value || '—'}
            </div>
          );
        },
      });

      baseColumns.push({
        accessorKey: 'unit_of_measure',
        header: () => <div className="text-center">UOM</div>,
        size: 100,
        cell: ({ row }) => {
          const value = row.original.unit_of_measure;
          const rowIndex = row.index;
          const isEditing = editingRowId === rowIndex;

          if (isEditing) {
            return (
              <div className="text-center">
                <select
                  value={value || ''}
                  onChange={(e) => handleCellChangeAndSave(rowIndex, 'unit_of_measure', e.target.value)}
                  onBlur={() => setEditingRowId(null)}
                  autoFocus
                  disabled={uomChoices.length === 0}
                  className="tw-w-full px-2 py-1 tw-text-sm border rounded focus:ring-2 focus:ring-blue-500"
                  style={{
                    backgroundColor: 'var(--cui-body-bg)',
                    color: 'var(--cui-body-color)',
                    borderColor: 'var(--cui-border-color)',
                  }}
                >
                  {uomChoices.length === 0 ? (
                    <option value="">No UOM options configured</option>
                  ) : (
                    uomChoices.map(opt => (
                      <option key={opt.value} value={opt.value}>
                        {opt.label}
                      </option>
                    ))
                  )}
                </select>
              </div>
            );
          }

          return (
            <div className="text-center tw-text-sm tw-cursor-pointer" onClick={() => setEditingRowId(rowIndex)}>
              {value || '—'}
            </div>
          );
        },
      });

      baseColumns.push({
        accessorKey: 'price_per_unit',
        header: () => <div className="text-right">Current<br />Price</div>,
        size: 140,
        cell: ({ row }) => {
          const value = row.original.price_per_unit;
          const rowIndex = row.index;

          return (
            <EditablePriceCell
              value={value}
              onSave={async (newValue) => {
                // Update the row value
                const updatedRows = [...editingRows];
                updatedRows[rowIndex] = { ...updatedRows[rowIndex], price_per_unit: newValue || 0 };
                setEditingRows(updatedRows);

                // Auto-save ONLY this row
                setIsSaving(true);
                try {
                  await saveMutation.mutateAsync({
                    projectId,
                    assumptions: [updatedRows[rowIndex]], // Only save this row
                  });
                  // Clear this row from dirty set
                  setDirtyRowIndices(prev => {
                    const next = new Set(prev);
                    next.delete(rowIndex);
                    return next;
                  });
                } catch (err) {
                  alert('Failed to save price');
                } finally {
                  setIsSaving(false);
                }
              }}
            />
          );
        },
      });

      baseColumns.push({
        id: 'actions',
        header: '',
        size: 60,
        cell: ({ row }) => {
          const rowIndex = row.index;
          return (
      <div className="text-center">
        <SemanticButton
          intent="destructive-action"
          variant="ghost"
          size="sm"
          className="pricing-delete-btn"
          onClick={() => handleDeleteRow(rowIndex)}
          title="Delete pricing"
          disabled={isSaving}
        >
          <Trash2 className="w-4 h-4" />
        </SemanticButton>
      </div>
          );
        },
      });

    // Conditionally add growth rate column based on mode
    // Napkin/Standard: hide column (use global dropdown instead), show Family column
    // Detail: show Growth Rate column, hide Family column
    if (mode === 'detail') {
      baseColumns.splice(baseColumns.length - 1, 0, {
        accessorKey: 'growth_rate',
        header: () => <div className="text-center">Growth<br />Rate</div>,
        size: 110,
        cell: ({ row }) => {
          const value = row.original.growth_rate;
          const rowIndex = row.index;
          const isEditing = editingRowId === rowIndex;

          if (isEditing) {
            // Check if current value is in options list
            const isCustomRate = !growthRateOptions.some(opt => Math.abs(opt.value - (value || 0)) < 0.0001);

            return (
              <div className="text-center tw-flex tw-flex-col gap-1">
                <select
                  value={isCustomRate ? 'custom' : String(value || '')}
                  onChange={(e) => {
                    if (e.target.value === 'custom') {
                      setCustomGrowthRate(String((value || 0) * 100));
                    } else {
                      handleCellChangeAndSave(rowIndex, 'growth_rate', parseFloat(e.target.value));
                      setCustomGrowthRate('');
                    }
                  }}
                  disabled={growthRateOptions.length === 0}
                  className="tw-w-full px-2 py-1 tw-text-sm border rounded focus:ring-2 focus:ring-blue-500"
                  style={{
                    backgroundColor: 'var(--cui-body-bg)',
                    color: 'var(--cui-body-color)',
                    borderColor: 'var(--cui-border-color)',
                  }}
                >
                  {growthRateOptions.length === 0 ? (
                    <option value="">No benchmarks configured</option>
                  ) : (
                    <>
                      {growthRateOptions.map(opt => (
                        <option key={opt.id} value={opt.value}>
                          {opt.label}
                        </option>
                      ))}
                      <option value="custom">Custom...</option>
                    </>
                  )}
                </select>
                {(isCustomRate || customGrowthRate !== '') && (
                  <div className="tw-flex tw-justify-center">
                    <input
                      type="text"
                      value={isCustomRate ? ((value || 0) * 100).toFixed(2) : customGrowthRate}
                      onChange={(e) => {
                        const rawValue = e.target.value.replace(/%/g, '');
                        if (rawValue === '' || !isNaN(Number(rawValue))) {
                          const numValue = Number(rawValue) / 100;
                          handleCellChange(rowIndex, 'growth_rate', numValue);
                          setCustomGrowthRate(rawValue);
                        }
                      }}
                      onBlur={(e) => {
                        const rawValue = e.target.value.replace(/%/g, '');
                        if (rawValue !== '' && !isNaN(Number(rawValue))) {
                          const numValue = Number(rawValue) / 100;
                          handleCellChangeAndSave(rowIndex, 'growth_rate', numValue);
                        }
                      }}
                      placeholder="%"
                      className="tw-w-1/2 px-2 py-1 tw-text-sm text-center border rounded focus:ring-2 focus:ring-blue-500"
                      style={{
                        backgroundColor: 'var(--cui-body-bg)',
                        color: 'var(--cui-body-color)',
                        borderColor: 'var(--cui-border-color)',
                      }}
                    />
                  </div>
                )}
              </div>
            );
          }

          const percentage = ((value || 0) * 100).toFixed(1);
          return (
            <div className="text-center tw-text-sm tnum tw-cursor-pointer" onClick={() => setEditingRowId(rowIndex)}>
              {percentage}%
            </div>
          );
        },
      });
    }

    return baseColumns;
  },
    [parcelProducts, editingRowId, uomChoices, isSaving, growthRateOptions, customGrowthRate, mode, handleCellChangeAndSave, handleCellChange]
  );

  const table = useReactTable({
    data: editingRows,
    columns,
    getCoreRowModel: getCoreRowModel(),
  });

  if (isLoading || isLoadingProducts) {
    return (
      <div className="rounded border p-4" style={{ backgroundColor: 'var(--cui-card-bg)', borderColor: 'var(--cui-border-color)' }}>
        <div className="tw-animate-pulse tw-space-y-3">
          <div className="h-8 rounded tw-w-full" style={{ backgroundColor: 'var(--cui-tertiary-bg)' }}></div>
          {[...Array(3)].map((_, i) => (
            <div key={i} className="h-12 rounded" style={{ backgroundColor: 'var(--cui-tertiary-bg)' }}></div>
          ))}
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-4 border rounded" style={{ backgroundColor: 'var(--cui-danger-bg)', borderColor: 'var(--cui-danger)', color: 'var(--cui-danger)' }}>
        <p>Failed to load pricing assumptions</p>
      </div>
    );
  }

  // Empty state - only show if no parcel products exist
  if ((!editingRows || editingRows.length === 0) && (!parcelProducts || parcelProducts.length === 0)) {
    return (
      <div className="rounded border p-8 text-center" style={{ backgroundColor: 'var(--cui-card-bg)', borderColor: 'var(--cui-border-color)' }}>
        <div className="mb-4" style={{ color: 'var(--cui-secondary-color)' }}>
          <p className="tw-text-lg tw-font-medium">No parcels configured</p>
          <p className="tw-text-sm mt-2">Add parcels to the project first, then pricing will auto-populate</p>
        </div>
      </div>
    );
  }

  return (
    <div className="rounded border tw-overflow-hidden" style={{ backgroundColor: 'var(--cui-card-bg)', borderColor: 'var(--cui-border-color)' }}>
      {/* Header */}
      <div className="px-4 py-3 tw-border-b tw-flex tw-justify-between tw-items-center" style={{ backgroundColor: 'var(--cui-tertiary-bg)', borderColor: 'var(--cui-border-color)' }}>
        <div className="tw-flex tw-items-center gap-4 tw-w-full">
          <h3 className="tw-text-sm tw-font-semibold" style={{ color: 'var(--cui-body-color)' }}>
            Land Use Pricing Assumptions
          </h3>
        </div>

        <div className="tw-flex gap-2">
          {hasUnsavedChanges && (
            <>
              <SemanticButton
                intent="secondary-action"
                size="sm"
                className="pricing-cancel-btn"
                onClick={handleCancel}
                disabled={isSaving}
              >
                <X className="w-4 h-4" />
                Cancel
              </SemanticButton>
              <SemanticButton
                intent="primary-action"
                size="sm"
                className="pricing-save-btn"
                onClick={handleSave}
                disabled={isSaving}
              >
                <Save className="w-4 h-4" />
                {isSaving ? 'Saving...' : `Save Changes (${dirtyRowIndices.size})`}
              </SemanticButton>
            </>
          )}
        </div>
      </div>

      {/* Table */}
      <div className="tw-overflow-x-auto">
        <table className="tw-w-full tw-text-sm">
          <thead style={{ backgroundColor: 'var(--surface-subheader)' }}>
            {table.getHeaderGroups().map((headerGroup) => (
              <tr key={headerGroup.id} className="tw-border-b" style={{ borderColor: 'var(--cui-border-color)' }}>
                {headerGroup.headers.map((header) => (
                  <th
                    key={header.id}
                    className="px-2 py-2 tw-font-medium"
                    style={{
                      color: 'var(--cui-body-color)',
                      width: header.column.columnDef.size ? `${header.column.columnDef.size}px` : undefined
                    }}
                  >
                    {flexRender(header.column.columnDef.header, header.getContext())}
                  </th>
                ))}
              </tr>
            ))}
          </thead>
          <tbody>
            {table.getRowModel().rows.map((row) => {
              const isEditing = editingRowId === row.index;
              const isNew = !row.original.id;
              const rowBg = isEditing
                ? 'var(--cui-primary-bg)'
                : isNew
                ? 'var(--cui-success-bg)'
                : 'var(--cui-card-bg)';

              return (
                <tr
                  key={row.id}
                  className="tw-border-b tw-transition-colors"
                  style={{
                    borderColor: 'var(--cui-border-color)',
                    backgroundColor: rowBg,
                  }}
                  onMouseEnter={(e) => {
                    if (!isEditing && !isNew) {
                      e.currentTarget.style.backgroundColor = 'var(--cui-tertiary-bg)';
                    }
                  }}
                  onMouseLeave={(e) => {
                    if (!isEditing && !isNew) {
                      e.currentTarget.style.backgroundColor = 'var(--cui-card-bg)';
                    }
                  }}
                >
                  {row.getVisibleCells().map((cell) => (
                    <td key={cell.id} className="px-2 py-1.5" style={{ color: 'var(--cui-body-color)' }}>
                      {flexRender(cell.column.columnDef.cell, cell.getContext())}
                    </td>
                  ))}
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>

      {/* Footer with Add button */}
      <div className="px-4 py-3 tw-border-t tw-flex tw-justify-between tw-items-center" style={{ backgroundColor: 'var(--cui-tertiary-bg)', borderColor: 'var(--cui-border-color)' }}>
        <span className="tw-text-sm" style={{ color: 'var(--cui-secondary-color)' }}>
          {editingRows.length} pricing assumption(s)
        </span>
        <SemanticButton
          intent="primary-action"
          size="sm"
          className="pricing-add-btn"
          onClick={handleAddRow}
          disabled={isSaving}
        >
          <Plus className="w-4 h-4" />
          Add Pricing
        </SemanticButton>
      </div>
    </div>
  );
}
