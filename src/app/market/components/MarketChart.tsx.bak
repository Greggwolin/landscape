import React, { useMemo } from 'react';
import {
  ResponsiveContainer,
  LineChart,
  Line,
  CartesianGrid,
  XAxis,
  YAxis,
  Tooltip,
  Legend,
} from 'recharts';

export interface SeriesPoint {
  date: string;
  value: string | null;
  coverage_note?: string | null;
}

export interface MarketSeries {
  series_code: string;
  series_name: string;
  geo_id: string;
  geo_name: string;
  geo_level?: string;
  units?: string | null;
  seasonal?: string | null;
  category?: string | null;
  subcategory?: string | null;
  data: SeriesPoint[];
}

interface MarketChartProps {
  title: string;
  series: MarketSeries[];
  yLabel?: string;
  valueFormatter?: (value: number) => string;
  subtitle?: string;
  footnote?: string;
  tooltipValueFormatter?: (value: number) => string;
}

const COLORS = ['#60a5fa', '#facc15', '#f97316', '#34d399', '#f472b6'];

const MarketChart: React.FC<MarketChartProps> = ({
  title,
  series,
  yLabel,
  valueFormatter,
  subtitle,
  footnote,
  tooltipValueFormatter,
}) => {
  // Filter out series with no data
  const seriesWithData = useMemo(() => {
    return series.filter((serie) => serie.data && serie.data.length > 0);
  }, [series]);

  const chartData = useMemo(() => {
    if (!seriesWithData.length) return [];
    const merged = new Map<string, Record<string, number | null>>();

    seriesWithData.forEach((serie) => {
      serie.data.forEach((point) => {
        const value = point.value != null ? Number(point.value) : null;
        if (!merged.has(point.date)) {
          merged.set(point.date, { date: point.date });
        }
        merged.get(point.date)![`${serie.series_code}-${serie.geo_id}`] = value;
      });
    });

  return Array.from(merged.values()).sort((a, b) => (a.date as string).localeCompare(b.date as string));
}, [seriesWithData]);

  const resolveTooltipValue = (value: unknown) => {
    if (typeof value !== 'number') {
      return value ?? 'n/a';
    }
    return tooltipValueFormatter
      ? tooltipValueFormatter(value)
      : value.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 });
  };

  if (!seriesWithData.length) {
    return (
      <div className="tw-bg-gray-900 border tw-border-gray-700 tw-rounded-lg p-4">
        <div className="tw-text-sm tw-text-gray-400">{title}</div>
        <div className="tw-text-sm tw-text-gray-500 mt-4">No data available.</div>
      </div>
    );
  }

  return (
    <div className="tw-bg-gray-900 border tw-border-gray-700 tw-rounded-lg p-4">
      <div className="mb-2">
        <div className="tw-text-sm tw-text-gray-300">{title}</div>
        {subtitle ? <div className="mt-0.5 tw-text-xs tw-text-gray-500">{subtitle}</div> : null}
      </div>
      <div className="h-72">
        <ResponsiveContainer width="100%" height="100%">
          <LineChart data={chartData}>
            <CartesianGrid strokeDasharray="3 3" stroke="#282c34" />
            <XAxis
              dataKey="date"
              tick={{ fill: '#9ca3af', fontSize: 11 }}
              tickFormatter={(value) => {
                if (!value) return '';
                const date = value.toString();
                // Format: 2024-01 -> Jan '24
                const [year, month] = date.split('-');
                if (!year || !month) return date;
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                return `${monthNames[parseInt(month) - 1]} '${year.slice(2)}`;
              }}
            />
            <YAxis
              tick={{ fill: '#9ca3af', fontSize: 12 }}
              tickFormatter={(value) => (typeof valueFormatter === 'function' ? valueFormatter(value) : value)}
              label={
                yLabel
                  ? { value: yLabel, angle: -90, position: 'insideLeft', fill: '#9ca3af', offset: 10 }
                  : undefined
              }
            />
            <Tooltip
              contentStyle={{ backgroundColor: '#111827', borderColor: '#1f2937' }}
              formatter={(value: unknown, name: string) => [resolveTooltipValue(value), name]}
              labelFormatter={(label) => {
                if (!label) return '';
                const date = label.toString();
                const [year, month] = date.split('-');
                if (!year || !month) return date;
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                return `${monthNames[parseInt(month, 10) - 1]} ${year}`;
              }}
            />
            <Legend wrapperStyle={{ color: '#d1d5db' }} />
            {seriesWithData.map((serie, index) => (
              <Line
                key={`${serie.series_code}-${serie.geo_id}`}
                type="monotone"
                dataKey={`${serie.series_code}-${serie.geo_id}`}
                name={`${serie.series_name} Â· ${serie.geo_name}`}
                stroke={COLORS[index % COLORS.length]}
                strokeWidth={2}
                dot={false}
                isAnimationActive={false}
                connectNulls={true}
                strokeLinecap="round"
                strokeLinejoin="round"
              />
            ))}
          </LineChart>
        </ResponsiveContainer>
      </div>
      {footnote ? <div className="mt-3 tw-text-xs tw-text-gray-500">{footnote}</div> : null}
    </div>
  );
};

export default MarketChart;
