import { NextResponse } from 'next/server'
import { sql } from '@/lib/db'

export const dynamic = 'force-dynamic'

/**
 * GET /api/budget/rollup
 *
 * Get budget rollup/aggregation with container hierarchy support
 *
 * Query Parameters:
 * - container_id?: number - Rollup for specific container (includes all children)
 * - project_id?: number - Rollup for entire project
 * - group_by?: string - Grouping: 'container_level'|'container'|'category' (default: 'container_level')
 * - max_level?: number - Maximum container level to include (1|2|3)
 *
 * Returns:
 * - rollup: Array of aggregated budget data
 * - total: Grand total across all groups
 * - hierarchy: Nested structure (when group_by='container')
 */
export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url)

    const containerId = searchParams.get('container_id')
    const projectId = searchParams.get('project_id')
    const groupBy = searchParams.get('group_by') || 'container_level'
    const maxLevel = searchParams.get('max_level')

    if (!containerId && !projectId) {
      return NextResponse.json(
        {
          success: false,
          error: 'Missing required parameters',
          details: 'Provide either container_id or project_id'
        },
        { status: 400 }
      )
    }

    let rollup

    if (groupBy === 'container_level') {
      // Rollup by container level (0=project, 1=area, 2=phase, 3=parcel)
      if (containerId) {
        // Rollup for a container and its children
        rollup = await sql`
          WITH RECURSIVE container_tree AS (
            -- Start with the specified container
            SELECT container_id, container_level, project_id, parent_container_id
            FROM landscape.tbl_container
            WHERE container_id = ${containerId}

            UNION ALL

            -- Recursively get all children
            SELECT c.container_id, c.container_level, c.project_id, c.parent_container_id
            FROM landscape.tbl_container c
            INNER JOIN container_tree ct ON c.parent_container_id = ct.container_id
          )
          SELECT
            COALESCE(c.container_level, 0) as container_level,
            CASE
              WHEN c.container_level IS NULL THEN 'Project'
              WHEN c.container_level = 1 THEN 'Level 1'
              WHEN c.container_level = 2 THEN 'Level 2'
              WHEN c.container_level = 3 THEN 'Level 3'
            END as level_name,
            COUNT(b.fact_id)::int as item_count,
            SUM(b.amount) as total_amount,
            AVG(b.amount) as avg_amount,
            MIN(b.amount) as min_amount,
            MAX(b.amount) as max_amount,
            COUNT(DISTINCT b.container_id) as container_count
          FROM landscape.core_fin_fact_budget b
          LEFT JOIN landscape.tbl_container c ON b.container_id = c.container_id
          WHERE b.container_id IN (SELECT container_id FROM container_tree)
            ${maxLevel ? sql`AND c.container_level <= ${maxLevel}` : sql``}
          GROUP BY c.container_level
          ORDER BY COALESCE(c.container_level, 0)
        `
      } else if (projectId) {
        // Rollup for entire project
        rollup = await sql`
          SELECT
            COALESCE(c.container_level, 0) as container_level,
            CASE
              WHEN c.container_level IS NULL THEN 'Project'
              WHEN c.container_level = 1 THEN 'Level 1'
              WHEN c.container_level = 2 THEN 'Level 2'
              WHEN c.container_level = 3 THEN 'Level 3'
            END as level_name,
            COUNT(b.fact_id)::int as item_count,
            SUM(b.amount) as total_amount,
            AVG(b.amount) as avg_amount,
            MIN(b.amount) as min_amount,
            MAX(b.amount) as max_amount,
            COUNT(DISTINCT b.container_id) as container_count
          FROM landscape.core_fin_fact_budget b
          LEFT JOIN landscape.tbl_container c ON b.container_id = c.container_id
          WHERE (b.pe_level = 'project' AND b.pe_id = ${projectId})
             OR (c.project_id = ${projectId})
            ${maxLevel ? sql`AND (c.container_level IS NULL OR c.container_level <= ${maxLevel})` : sql``}
          GROUP BY c.container_level
          ORDER BY COALESCE(c.container_level, 0)
        `
      }
    } else if (groupBy === 'container') {
      // Rollup by individual container
      if (containerId) {
        rollup = await sql`
          WITH RECURSIVE container_tree AS (
            SELECT container_id, container_level, project_id, parent_container_id,
                   container_code, display_name, sort_order
            FROM landscape.tbl_container
            WHERE container_id = ${containerId}

            UNION ALL

            SELECT c.container_id, c.container_level, c.project_id, c.parent_container_id,
                   c.container_code, c.display_name, c.sort_order
            FROM landscape.tbl_container c
            INNER JOIN container_tree ct ON c.parent_container_id = ct.container_id
          )
          SELECT
            c.container_id,
            c.container_level,
            c.container_code,
            c.display_name as container_name,
            c.parent_container_id,
            c.sort_order,
            COUNT(b.fact_id)::int as item_count,
            SUM(b.amount) as total_amount,
            AVG(b.amount) as avg_amount
          FROM container_tree c
          LEFT JOIN landscape.core_fin_fact_budget b ON b.container_id = c.container_id
          ${maxLevel ? sql`WHERE c.container_level <= ${maxLevel}` : sql``}
          GROUP BY c.container_id, c.container_level, c.container_code,
                   c.display_name, c.parent_container_id, c.sort_order
          ORDER BY c.container_level, c.sort_order
        `
      } else if (projectId) {
        rollup = await sql`
          SELECT
            c.container_id,
            c.container_level,
            c.container_code,
            c.display_name as container_name,
            c.parent_container_id,
            c.sort_order,
            COUNT(b.fact_id)::int as item_count,
            SUM(b.amount) as total_amount,
            AVG(b.amount) as avg_amount
          FROM landscape.tbl_container c
          LEFT JOIN landscape.core_fin_fact_budget b ON b.container_id = c.container_id
          WHERE c.project_id = ${projectId}
            ${maxLevel ? sql`AND c.container_level <= ${maxLevel}` : sql``}
          GROUP BY c.container_id, c.container_level, c.container_code,
                   c.display_name, c.parent_container_id, c.sort_order
          ORDER BY c.container_level, c.sort_order
        `
      }
    } else if (groupBy === 'category') {
      // Rollup by category
      if (containerId) {
        rollup = await sql`
          WITH RECURSIVE container_tree AS (
            SELECT container_id
            FROM landscape.tbl_container
            WHERE container_id = ${containerId}

            UNION ALL

            SELECT c.container_id
            FROM landscape.tbl_container c
            INNER JOIN container_tree ct ON c.parent_container_id = ct.container_id
          )
          SELECT
            cat.category_id,
            cat.code as category_code,
            cat.detail as category_name,
            cat.scope as category_scope,
            COUNT(b.fact_id)::int as item_count,
            SUM(b.amount) as total_amount,
            AVG(b.amount) as avg_amount
          FROM landscape.core_fin_fact_budget b
          INNER JOIN landscape.core_fin_category cat ON b.category_id = cat.category_id
          WHERE b.container_id IN (SELECT container_id FROM container_tree)
          GROUP BY cat.category_id, cat.code, cat.detail, cat.depth
          ORDER BY cat.depth, cat.code
        `
      } else if (projectId) {
        rollup = await sql`
          SELECT
            cat.category_id,
            cat.code as category_code,
            cat.detail as category_name,
            cat.scope as category_scope,
            COUNT(b.fact_id)::int as item_count,
            SUM(b.amount) as total_amount,
            AVG(b.amount) as avg_amount
          FROM landscape.core_fin_fact_budget b
          INNER JOIN landscape.core_fin_category cat ON b.category_id = cat.category_id
          LEFT JOIN landscape.tbl_container c ON b.container_id = c.container_id
          WHERE (b.pe_level = 'project' AND b.pe_id = ${projectId})
             OR (c.project_id = ${projectId})
          GROUP BY cat.category_id, cat.code, cat.detail, cat.depth
          ORDER BY cat.depth, cat.code
        `
      }
    } else {
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid group_by parameter',
          details: "Must be one of: 'container_level', 'container', 'category'"
        },
        { status: 400 }
      )
    }

    // Calculate grand total
    const grandTotal = rollup.reduce(
      (sum: number, row: any) => sum + (Number(row.total_amount) || 0),
      0
    )

    // Build hierarchy if grouping by container
    let hierarchy = null
    if (groupBy === 'container') {
      hierarchy = buildContainerHierarchy(rollup)
    }

    return NextResponse.json({
      success: true,
      data: {
        rollup,
        grandTotal,
        itemCount: rollup.reduce(
          (sum: number, row: any) => sum + (Number(row.item_count) || 0),
          0
        ),
        groupBy,
        hierarchy
      }
    })
  } catch (error) {
    console.error('Error calculating budget rollup:', error)
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to calculate budget rollup',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    )
  }
}

/**
 * Build hierarchical tree structure from flat container list
 */
function buildContainerHierarchy(containers: any[]): any[] {
  const map = new Map<number, any>()
  const roots: any[] = []

  // First pass: create map
  containers.forEach((container) => {
    map.set(container.container_id, {
      ...container,
      children: []
    })
  })

  // Second pass: build tree
  containers.forEach((container) => {
    const node = map.get(container.container_id)
    if (container.parent_container_id) {
      const parent = map.get(container.parent_container_id)
      if (parent) {
        parent.children.push(node)
      } else {
        roots.push(node)
      }
    } else {
      roots.push(node)
    }
  })

  return roots
}
