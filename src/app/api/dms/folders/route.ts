import { NextRequest, NextResponse } from 'next/server';
import { sql } from '@/lib/dms/db';
import { CreateFolderZ, UpdateFolderZ, FolderZ, FolderTreeNodeZ } from './schema';
import { z } from 'zod';

/**
 * GET /api/dms/folders
 * Returns folder tree with optional filtering
 */
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const flat = searchParams.get('flat') === 'true'; // Return flat list instead of tree
    const includeInactive = searchParams.get('include_inactive') === 'true';

    // Build WHERE clause
    const whereConditions = [];
    if (!includeInactive) {
      whereConditions.push("is_active = true");
    }

    const whereClause = whereConditions.length > 0
      ? `WHERE ${whereConditions.join(' AND ')}`
      : '';

    // Fetch all folders
    const result = await sql`
      SELECT
        folder_id,
        parent_id,
        name,
        path,
        sort_order,
        default_profile,
        is_active,
        created_at,
        updated_at,
        (SELECT COUNT(*) FROM landscape.core_doc_folder_link WHERE folder_id = f.folder_id) as doc_count
      FROM landscape.core_doc_folder f
      ${sql.raw(whereClause)}
      ORDER BY sort_order, name
    `;

    const folders = result.rows.map(row => ({
      ...row,
      created_at: row.created_at.toISOString(),
      updated_at: row.updated_at.toISOString(),
    }));

    // If flat list requested, return as is
    if (flat) {
      return NextResponse.json({
        success: true,
        folders,
      });
    }

    // Build tree structure
    const folderMap = new Map();
    const rootFolders: any[] = [];

    // First pass: create map
    folders.forEach(folder => {
      folderMap.set(folder.folder_id, { ...folder, children: [] });
    });

    // Second pass: build tree
    folders.forEach(folder => {
      const node = folderMap.get(folder.folder_id);
      if (folder.parent_id === null) {
        rootFolders.push(node);
      } else {
        const parent = folderMap.get(folder.parent_id);
        if (parent) {
          parent.children.push(node);
        } else {
          // Parent doesn't exist or is inactive, treat as root
          rootFolders.push(node);
        }
      }
    });

    return NextResponse.json({
      success: true,
      tree: rootFolders,
      totalFolders: folders.length,
    });

  } catch (error) {
    console.error('Error fetching folders:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to fetch folders',
        details: error instanceof Error ? error.message : String(error)
      },
      { status: 500 }
    );
  }
}

/**
 * POST /api/dms/folders
 * Create new folder
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const data = CreateFolderZ.parse(body);

    // Validate parent exists if specified
    if (data.parent_id) {
      const parentCheck = await sql`
        SELECT folder_id FROM landscape.core_doc_folder
        WHERE folder_id = ${data.parent_id} AND is_active = true
      `;

      if (parentCheck.rows.length === 0) {
        return NextResponse.json(
          { success: false, error: 'Parent folder not found' },
          { status: 404 }
        );
      }
    }

    // Insert folder (path is auto-generated by trigger)
    const result = await sql`
      INSERT INTO landscape.core_doc_folder (
        name,
        parent_id,
        sort_order,
        default_profile
      ) VALUES (
        ${data.name},
        ${data.parent_id || null},
        ${data.sort_order},
        ${JSON.stringify(data.default_profile)}
      )
      RETURNING
        folder_id,
        parent_id,
        name,
        path,
        sort_order,
        default_profile,
        is_active,
        created_at,
        updated_at
    `;

    const folder = result.rows[0];

    return NextResponse.json({
      success: true,
      folder: {
        ...folder,
        created_at: folder.created_at.toISOString(),
        updated_at: folder.updated_at.toISOString(),
      },
    }, { status: 201 });

  } catch (error) {
    console.error('Error creating folder:', error);

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        {
          success: false,
          error: 'Validation error',
          details: error.errors
        },
        { status: 400 }
      );
    }

    return NextResponse.json(
      {
        success: false,
        error: 'Failed to create folder',
        details: error instanceof Error ? error.message : String(error)
      },
      { status: 500 }
    );
  }
}

/**
 * PATCH /api/dms/folders
 * Update existing folder
 */
export async function PATCH(request: NextRequest) {
  try {
    const body = await request.json();
    const data = UpdateFolderZ.parse(body);

    // Check folder exists
    const folderCheck = await sql`
      SELECT folder_id FROM landscape.core_doc_folder
      WHERE folder_id = ${data.folder_id}
    `;

    if (folderCheck.rows.length === 0) {
      return NextResponse.json(
        { success: false, error: 'Folder not found' },
        { status: 404 }
      );
    }

    // Validate parent exists if specified
    if (data.parent_id !== undefined && data.parent_id !== null) {
      // Prevent self-referencing
      if (data.parent_id === data.folder_id) {
        return NextResponse.json(
          { success: false, error: 'Folder cannot be its own parent' },
          { status: 400 }
        );
      }

      const parentCheck = await sql`
        SELECT folder_id FROM landscape.core_doc_folder
        WHERE folder_id = ${data.parent_id} AND is_active = true
      `;

      if (parentCheck.rows.length === 0) {
        return NextResponse.json(
          { success: false, error: 'Parent folder not found' },
          { status: 404 }
        );
      }
    }

    // Build UPDATE query
    const updates: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    if (data.name !== undefined) {
      updates.push(`name = $${paramIndex++}`);
      values.push(data.name);
    }

    if (data.parent_id !== undefined) {
      updates.push(`parent_id = $${paramIndex++}`);
      values.push(data.parent_id);
    }

    if (data.sort_order !== undefined) {
      updates.push(`sort_order = $${paramIndex++}`);
      values.push(data.sort_order);
    }

    if (data.default_profile !== undefined) {
      updates.push(`default_profile = $${paramIndex++}`);
      values.push(JSON.stringify(data.default_profile));
    }

    if (data.is_active !== undefined) {
      updates.push(`is_active = $${paramIndex++}`);
      values.push(data.is_active);
    }

    if (updates.length === 0) {
      return NextResponse.json(
        { success: false, error: 'No fields to update' },
        { status: 400 }
      );
    }

    // Add folder_id to values
    values.push(data.folder_id);

    const result = await sql.query(
      `UPDATE landscape.core_doc_folder
       SET ${updates.join(', ')}, updated_at = NOW()
       WHERE folder_id = $${paramIndex}
       RETURNING
         folder_id,
         parent_id,
         name,
         path,
         sort_order,
         default_profile,
         is_active,
         created_at,
         updated_at`,
      values
    );

    const folder = result.rows[0];

    return NextResponse.json({
      success: true,
      folder: {
        ...folder,
        created_at: folder.created_at.toISOString(),
        updated_at: folder.updated_at.toISOString(),
      },
    });

  } catch (error) {
    console.error('Error updating folder:', error);

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        {
          success: false,
          error: 'Validation error',
          details: error.errors
        },
        { status: 400 }
      );
    }

    return NextResponse.json(
      {
        success: false,
        error: 'Failed to update folder',
        details: error instanceof Error ? error.message : String(error)
      },
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/dms/folders/:id
 * Soft delete folder (sets is_active = false)
 */
export async function DELETE(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const folderId = searchParams.get('folder_id');

    if (!folderId) {
      return NextResponse.json(
        { success: false, error: 'folder_id is required' },
        { status: 400 }
      );
    }

    // Check if folder has children
    const childrenCheck = await sql`
      SELECT COUNT(*) as count
      FROM landscape.core_doc_folder
      WHERE parent_id = ${folderId} AND is_active = true
    `;

    if (parseInt(childrenCheck.rows[0].count) > 0) {
      return NextResponse.json(
        { success: false, error: 'Cannot delete folder with active children' },
        { status: 400 }
      );
    }

    // Soft delete
    const result = await sql`
      UPDATE landscape.core_doc_folder
      SET is_active = false, updated_at = NOW()
      WHERE folder_id = ${folderId}
      RETURNING folder_id
    `;

    if (result.rows.length === 0) {
      return NextResponse.json(
        { success: false, error: 'Folder not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      folder_id: parseInt(folderId),
    });

  } catch (error) {
    console.error('Error deleting folder:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to delete folder',
        details: error instanceof Error ? error.message : String(error)
      },
      { status: 500 }
    );
  }
}
