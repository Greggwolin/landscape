'use client'

import React, { useState } from 'react'
import GISMap from '../MapLibre/GISMap'
import { reverseGeocode, type ReverseGeocodingResult } from '../../../lib/geocoding'

interface ProjectBoundarySetupProps {
 projectId: number
 onBoundaryConfirmed: (boundaryData: BoundaryData) => void
 onCancel?: () => void
 extractedData?: {
 project_location?: {
 addresses: string[]
 coordinates?: { latitude: number; longitude: number }
 legal_descriptions: string[]
 }
 total_acres?: number
 parcel_data?: Array<{
 parcel_id: string
 acres: number
 land_use?: string
 }>
 }
}

interface TaxParcel {
 PARCELID: string
 OWNERNME1?: string
 SITEADDRESS?: string
 GROSSAC?: number
 CNVYNAME?: string
 USEDSCRP?: string
 APPRAISEDVALUE?: number
 MARKETVALUE?: number
 geometry?: GeoJSON.Geometry
 properties?: Record<string, any>
}

interface BoundaryData {
 selectedParcels: TaxParcel[]
 totalAcres: number
 dissolvedBoundary?: GeoJSON.Geometry
 boundaryCenter?: [number, number]
 projectData: {
 estimatedAcres?: number
 county?: string
 city?: string
 totalValue?: number
 }
}

// Helper function to extract city from address
const extractCityFromAddress = (address?: string): string => {
 if (!address) return ''

 // Try to extract city from address pattern like"123 Main St, Phoenix, AZ 85001"
 const parts = address.split(',')
 if (parts.length >= 2) {
 const cityPart = parts[1].trim()
 // Remove state and zip code if present
 return cityPart.split(' ')[0] || ''
 }

 // Fallback: look for common Arizona cities in the address
 const arizonaCities = ['Phoenix', 'Tucson', 'Mesa', 'Chandler', 'Scottsdale', 'Glendale', 'Gilbert', 'Tempe', 'Peoria', 'Surprise', 'Yuma', 'Avondale', 'Flagstaff', 'Goodyear', 'Buckeye', 'Lake Havasu City', 'Casa Grande', 'Sierra Vista', 'Maricopa', 'Oro Valley', 'Prescott', 'Bullhead City', 'Prescott Valley', 'Apache Junction', 'Marana', 'Fountain Hills', 'Kingman', 'Nogales', 'Sahuarita', 'Eloy', 'Payson', 'Sedona', 'Show Low', 'Somerton', 'El Mirage', 'Paradise Valley', 'Tolleson', 'Cottonwood', 'Cave Creek', 'Chino Valley', 'Litchfield Park', 'Globe', 'San Luis', 'Wickenburg', 'Page', 'Carefree']

 for (const city of arizonaCities) {
 if (address.toUpperCase().includes(city.toUpperCase())) {
 return city
 }
 }

 return ''
}

export default function ProjectBoundarySetup({
 projectId,
 onBoundaryConfirmed,
 onCancel,
 extractedData
}: ProjectBoundarySetupProps) {
 const [selectedParcels, setSelectedParcels] = useState<TaxParcel[]>([])
 const [isSubmitting, setIsSubmitting] = useState(false)
 const [validationError, setValidationError] = useState<string>('')
 const [mapLocation, setMapLocation] = useState<ReverseGeocodingResult | null>(null)

 const handleParcelSelect = (features: Record<string, unknown>[]) => {
 console.log('ðŸ” Raw features received:', features)

 const parcels = features.map(feature => {
 // The data is nested in properties or attributes - let's extract it properly
 const props = (feature.properties || feature.attributes || feature) as Record<string, any>

 console.log('ðŸ“Š Processing feature:', feature)
 console.log('ðŸ“Š Properties:', props)

 const parcel = {
 PARCELID: props.PARCELID || props.parcelid || '',
 OWNERNME1: props.OWNERNME1 || props.ownernme1 || '',
 SITEADDRESS: props.SITEADDRESS || props.siteaddres || '',
 GROSSAC: props.GROSSAC || props.grossac || 0,
 CNVYNAME: props.CNVYNAME || props.cnvyname || '',
 USEDSCRP: props.USEDSCRP || props.usedscrp || '',
 APPRAISEDVALUE: props.APPRAISEDVALUE || props.appraisedvalue || 0,
 MARKETVALUE: props.MARKETVALUE || props.marketvalue || 0,
 geometry: feature.geometry as GeoJSON.Geometry,
 properties: props
 }

 console.log('âœ… Mapped parcel:', parcel)
 return parcel
 })

 console.log('ðŸŽ¯ Final parcels array:', parcels)
 setSelectedParcels(parcels)
 setValidationError('')
 }

 // Capture map location for reverse geocoding
 const handleMapClick = async (coordinates: { lat: number, lng: number }) => {
 console.log('ðŸ“ Map clicked at:', coordinates)
 try {
 const location = await reverseGeocode(coordinates.lat, coordinates.lng)
 if (location) {
 console.log('ðŸŒ Got location from map:', location)
 setMapLocation(location)
 }
 } catch (error) {
 console.error('Error reverse geocoding map location:', error)
 }
 }

 const calculateBoundaryData = (): BoundaryData => {
 const totalAcres = selectedParcels.reduce((sum, parcel) =>
 sum + (parcel.GROSSAC || 0), 0
 )

 // Find primary parcel (largest by acreage)
 const primaryParcel = selectedParcels.reduce((largest, current) =>
 (current.GROSSAC || 0) > (largest.GROSSAC || 0) ? current : largest
 , selectedParcels[0])

 const totalValue = selectedParcels.reduce((sum, parcel) =>
 sum + (parcel.MARKETVALUE || parcel.APPRAISEDVALUE || 0), 0
 )

 // Use GIS parcel data first, fallback to map location from reverse geocoding
 const county = primaryParcel?.CNVYNAME || mapLocation?.county || ''
 const city = extractCityFromAddress(primaryParcel?.SITEADDRESS) || mapLocation?.city || ''

 console.log('ðŸ“Š Boundary data sources:', {
 gisCounty: primaryParcel?.CNVYNAME,
 gisCity: extractCityFromAddress(primaryParcel?.SITEADDRESS),
 mapCounty: mapLocation?.county,
 mapCity: mapLocation?.city,
 finalCounty: county,
 finalCity: city
 })

 return {
 selectedParcels,
 totalAcres,
 projectData: {
 estimatedAcres: totalAcres,
 county,
 city,
 totalValue
 }
 }
 }

 const handleConfirmBoundary = async () => {
 if (selectedParcels.length === 0) {
 setValidationError('Please select at least one tax parcel to define the project boundary.')
 return
 }

 setIsSubmitting(true)
 try {
 const boundaryData = calculateBoundaryData()

 // Store boundary selection in database
 const response = await fetch('/api/gis/project-boundary', {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify({
 projectId,
 selectedParcels: boundaryData.selectedParcels,
 boundaryMetadata: {
 totalAcres: boundaryData.totalAcres,
 parcelCount: selectedParcels.length,
 createdAt: new Date().toISOString()
 }
 })
 })

 if (response.ok) {
 onBoundaryConfirmed(boundaryData)
 } else {
 const error = await response.json()
 setValidationError(`Failed to save boundary: ${error.message || error.error || 'Unknown error'}`)
 }
 } catch (error) {
 console.error('Error confirming boundary:', error)
 setValidationError('Failed to confirm project boundary. Please try again.')
 } finally {
 setIsSubmitting(false)
 }
 }

 const removeParcel = (parcelId: string) => {
 setSelectedParcels(prev => prev.filter(p => p.PARCELID !== parcelId))
 }

 const totalAcres = selectedParcels.reduce((sum, p) => sum + (p.GROSSAC || 0), 0)
 const totalValue = selectedParcels.reduce((sum, p) => sum + (p.MARKETVALUE || p.APPRAISEDVALUE || 0), 0)

 return (
 <div className="tw-w-full tw-h-full tw-flex tw-flex-col bg-body">
 {/* Header */}
 <div className="bg-body tw-border-b border px-6 py-4">
 <div className="tw-flex tw-items-center tw-justify-between">
 <div>
 <h2 className="tw-text-xl tw-font-bold text-body">Define Project Boundary</h2>
 <p className="text-body-tertiary tw-text-sm mt-1">
 Select tax parcels to establish your project boundaries and context
 </p>
 </div>
 {onCancel && (
 <button
 onClick={onCancel}
 className="px-4 py-2 tw-text-sm tw-font-medium text-body-tertiary hover:text-body"
 >
 Back
 </button>
 )}
 </div>
 </div>

 {/* Content */}
 <div className="tw-flex-1 tw-flex">
 {/* Map */}
 <div className="tw-flex-1">
 <GISMap
 projectId={projectId}
 mode="parcel-select"
 onParcelSelect={handleParcelSelect}
 onMapClick={handleMapClick}
 projectLocation={extractedData?.project_location ? {
 description: extractedData.project_location.addresses[0] || '',
 latitude: extractedData.project_location.coordinates?.latitude,
 longitude: extractedData.project_location.coordinates?.longitude,
 confidence: 0.9
 } : undefined}
 className="tw-w-full tw-h-full"
 />
 </div>

 {/* Selection Panel */}
 <div className="w-96 bg-body tw-border-l border tw-flex tw-flex-col">
 {/* Document Data Summary */}
 {extractedData && (
 <div className="p-4 tw-border-b border">
 <h3 className="tw-text-lg tw-font-semibold text-body mb-3">From Your Documents</h3>
 <div className="tw-space-y-3 tw-text-sm">
 {extractedData.project_location?.addresses && extractedData.project_location.addresses.length > 0 && (
 <div>
 <div className="text-body-tertiary mb-1">Project Location:</div>
 <div className="text-body">{extractedData.project_location.addresses[0]}</div>
 </div>
 )}
 {extractedData.total_acres && (
 <div>
 <div className="text-body-tertiary mb-1">Total Project Area:</div>
 <div className="text-body">{extractedData.total_acres} acres</div>
 </div>
 )}
 {extractedData.parcel_data && extractedData.parcel_data.length > 0 && (
 <div>
 <div className="text-body-tertiary mb-1">Plan Parcels Identified:</div>
 <div className="text-body">{extractedData.parcel_data.length} parcels</div>
 </div>
 )}
 </div>
 <div className="mt-3 tw-text-xs tw-text-blue-300">
 ðŸ’¡ Use this information to guide your tax parcel selection
 </div>
 </div>
 )}

 {/* Selection Summary */}
 <div className="p-4 tw-border-b border">
 <h3 className="tw-text-lg tw-font-semibold text-body mb-3">Selected Tax Parcels</h3>

 {selectedParcels.length === 0 ? (
 <div className="text-body-tertiary tw-text-sm">
 Click parcels on the map to select them for your project boundary.
 </div>
 ) : (
 <div className="tw-space-y-2 tw-text-sm">
 <div className="tw-flex tw-justify-between text-body">
 <span>Parcels:</span>
 <span className="tw-font-medium">{selectedParcels.length}</span>
 </div>
 <div className="tw-flex tw-justify-between text-body">
 <span>Total Acres:</span>
 <span className="tw-font-medium">{totalAcres.toFixed(2)}</span>
 </div>
 <div className="tw-flex tw-justify-between text-body">
 <span>Total Value:</span>
 <span className="tw-font-medium">${totalValue.toLocaleString()}</span>
 </div>
 </div>
 )}
 </div>

 {/* Parcel List */}
 <div className="tw-flex-1 tw-overflow-y-auto">
 {selectedParcels.map((parcel, index) => (
 <div key={parcel.PARCELID || `parcel-${index}`} className="p-3 tw-border-b border">
 <div className="tw-flex tw-items-start tw-justify-between">
 <div className="tw-flex-1 tw-min-w-0">
 <div className="text-body tw-font-medium tw-text-sm tw-truncate">
 {parcel.SITEADDRESS || 'No Address'}
 </div>
 <div className="text-body-tertiary tw-text-xs mt-1">
 ID: {parcel.PARCELID}
 </div>
 <div className="text-body-tertiary tw-text-xs mt-1">
 {parcel.GROSSAC?.toFixed(2)} acres
 </div>
 {parcel.OWNERNME1 && (
 <div className="text-body-tertiary tw-text-xs tw-truncate">
 Owner: {parcel.OWNERNME1}
 </div>
 )}
 </div>
 <button
 onClick={() => removeParcel(parcel.PARCELID)}
 className="ml-2 text-body-tertiary hover:tw-text-red-400 tw-text-xs"
 >
 Remove
 </button>
 </div>
 </div>
 ))}
 </div>

 {/* Actions */}
 <div className="p-4 tw-border-t border">
 {validationError && (
 <div className="mb-3 p-2 tw-bg-red-900/20 border tw-border-red-700 rounded tw-text-red-300 tw-text-sm">
 {validationError}
 </div>
 )}

 <button
 onClick={handleConfirmBoundary}
 disabled={selectedParcels.length === 0 || isSubmitting}
 className="tw-w-full px-4 py-2 tw-bg-blue-600 text-body tw-rounded-md disabled:bg-body disabled:tw-cursor-not-allowed tw-font-medium"
 >
 {isSubmitting ? 'Saving Boundary...' : `Confirm Boundary (${selectedParcels.length} parcels)`}
 </button>

 <div className="mt-2 tw-text-xs text-body-tertiary text-center">
 This boundary will provide context for AI document analysis
 </div>
 </div>
 </div>
 </div>
 </div>
 )
}