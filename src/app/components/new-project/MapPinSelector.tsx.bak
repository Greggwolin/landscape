'use client'

import { useEffect, useRef, useState, useCallback } from 'react'
import maplibregl from 'maplibre-gl'
import 'maplibre-gl/dist/maplibre-gl.css'
import { registerGoogleProtocol } from '@/lib/maps/registerGoogleProtocol'
import { getGoogleBasemapStyle } from '@/lib/maps/googleBasemaps'
import { registerRasterDim } from '@/lib/maps/rasterDim'

export interface GeocodeResult {
  city?: string
  county?: string
  state?: string
  zip?: string
  crossStreets?: string
  formattedAddress?: string
}

interface MapPinSelectorProps {
  latitude?: number
  longitude?: number
  onLocationSelect: (coords: { lat: number; lng: number }) => void
  onGeocode?: (result: GeocodeResult) => void
  className?: string
  isDark?: boolean
}

// Phoenix metro area default center
const DEFAULT_CENTER: [number, number] = [-112.074, 33.4484]
const DEFAULT_ZOOM = 10

const MapPinSelector = ({
  latitude,
  longitude,
  onLocationSelect,
  onGeocode,
  className = '',
  isDark = false
}: MapPinSelectorProps) => {
  const mapContainer = useRef<HTMLDivElement>(null)
  const map = useRef<maplibregl.Map | null>(null)
  const marker = useRef<maplibregl.Marker | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [geocodeStatus, setGeocodeStatus] = useState<'idle' | 'loading' | 'success' | 'error'>('idle')
  const [hasMarker, setHasMarker] = useState(false)

  // Reverse geocode using Nominatim (OpenStreetMap)
  const reverseGeocode = useCallback(async (lat: number, lng: number): Promise<GeocodeResult | null> => {
    setGeocodeStatus('loading')
    try {
      const response = await fetch(
        `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json&addressdetails=1`,
        {
          headers: {
            'User-Agent': 'Landscape-App/1.0'
          }
        }
      )

      if (!response.ok) {
        throw new Error('Geocoding failed')
      }

      const data = await response.json()
      const address = data.address || {}

      const result: GeocodeResult = {
        city: address.city || address.town || address.village || address.municipality,
        county: address.county?.replace(' County', ''),
        state: address.state,
        zip: address.postcode,
        formattedAddress: data.display_name
      }

      if (address.road) {
        result.crossStreets = address.road
      }

      setGeocodeStatus('success')
      return result
    } catch (error) {
      console.error('Reverse geocoding error:', error)
      setGeocodeStatus('error')
      return null
    }
  }, [])

  // Handle map click
  const handleMapClick = useCallback(async (e: maplibregl.MapMouseEvent) => {
    const { lng, lat } = e.lngLat

    if (marker.current) {
      marker.current.setLngLat([lng, lat])
    } else if (map.current) {
      marker.current = new maplibregl.Marker({
        color: '#3b82f6',
        draggable: true
      })
        .setLngLat([lng, lat])
        .addTo(map.current)

      marker.current.on('dragend', async () => {
        const lngLat = marker.current?.getLngLat()
        if (lngLat) {
          onLocationSelect({ lat: lngLat.lat, lng: lngLat.lng })
          if (onGeocode) {
            const result = await reverseGeocode(lngLat.lat, lngLat.lng)
            if (result) {
              onGeocode(result)
            }
          }
        }
      })
    }

    setHasMarker(true)
    onLocationSelect({ lat, lng })

    if (onGeocode) {
      const result = await reverseGeocode(lat, lng)
      if (result) {
        onGeocode(result)
      }
    }
  }, [onLocationSelect, onGeocode, reverseGeocode])

  // Initialize map
  useEffect(() => {
    if (!mapContainer.current || map.current) return

    let cleanupRasterDim: (() => void) | null = null

    const initialCenter: [number, number] =
      latitude && longitude ? [longitude, latitude] : DEFAULT_CENTER
    const initialZoom = latitude && longitude ? 14 : DEFAULT_ZOOM

    registerGoogleProtocol()
    map.current = new maplibregl.Map({
      container: mapContainer.current,
      style: getGoogleBasemapStyle('hybrid'),
      center: initialCenter,
      zoom: initialZoom,
      attributionControl: false
    })

    cleanupRasterDim = registerRasterDim(map.current, 0.1)

    map.current.addControl(
      new maplibregl.NavigationControl({ showCompass: false }),
      'top-right'
    )

    map.current.on('load', () => {
      setIsLoading(false)

      if (latitude && longitude && map.current) {
        marker.current = new maplibregl.Marker({
          color: '#3b82f6',
          draggable: true
        })
          .setLngLat([longitude, latitude])
          .addTo(map.current)

        setHasMarker(true)

        marker.current.on('dragend', async () => {
          const lngLat = marker.current?.getLngLat()
          if (lngLat) {
            onLocationSelect({ lat: lngLat.lat, lng: lngLat.lng })
            if (onGeocode) {
              const result = await reverseGeocode(lngLat.lat, lngLat.lng)
              if (result) {
                onGeocode(result)
              }
            }
          }
        })
      }
    })

    map.current.on('click', handleMapClick)

    return () => {
      if (map.current) {
        cleanupRasterDim?.()
        map.current.remove()
        map.current = null
      }
      marker.current = null
    }
  }, []) // eslint-disable-line react-hooks/exhaustive-deps

  // Track previous coordinates to detect changes
  const prevCoordsRef = useRef<{ lat?: number; lng?: number }>({})

  // Refs for callbacks to avoid effect dependency issues
  const onLocationSelectRef = useRef(onLocationSelect)
  const onGeocodeRef = useRef(onGeocode)
  const reverseGeocodeRef = useRef(reverseGeocode)

  // Keep refs updated
  useEffect(() => {
    onLocationSelectRef.current = onLocationSelect
    onGeocodeRef.current = onGeocode
    reverseGeocodeRef.current = reverseGeocode
  }, [onLocationSelect, onGeocode, reverseGeocode])

  // Update marker when external coordinates change
  // IMPORTANT: Only depend on lat/lng/isLoading - not callbacks
  useEffect(() => {
    console.log('[MapPinSelector] Coords effect - latitude:', latitude, 'longitude:', longitude, 'isLoading:', isLoading, 'map exists:', !!map.current)

    if (!map.current || isLoading) {
      console.log('[MapPinSelector] Skipping - map not ready or loading')
      return
    }

    if (latitude && longitude) {
      // Check if coordinates actually changed
      const coordsChanged = prevCoordsRef.current.lat !== latitude || prevCoordsRef.current.lng !== longitude
      console.log('[MapPinSelector] Coords changed:', coordsChanged, 'prev:', prevCoordsRef.current, 'new:', { lat: latitude, lng: longitude })

      if (marker.current) {
        marker.current.setLngLat([longitude, latitude])
      } else {
        marker.current = new maplibregl.Marker({
          color: '#3b82f6',
          draggable: true
        })
          .setLngLat([longitude, latitude])
          .addTo(map.current)

        marker.current.on('dragend', async () => {
          const lngLat = marker.current?.getLngLat()
          if (lngLat) {
            onLocationSelectRef.current({ lat: lngLat.lat, lng: lngLat.lng })
            if (onGeocodeRef.current) {
              const result = await reverseGeocodeRef.current(lngLat.lat, lngLat.lng)
              if (result) {
                onGeocodeRef.current(result)
              }
            }
          }
        })
      }

      setHasMarker(true)

      // Only fly if coordinates actually changed
      if (coordsChanged) {
        console.log('[MapPinSelector] Flying to:', [longitude, latitude])
        map.current.flyTo({
          center: [longitude, latitude],
          zoom: 14,
          duration: 1000
        })
        prevCoordsRef.current = { lat: latitude, lng: longitude }
      }
    }
  }, [latitude, longitude, isLoading]) // Only depend on the values that matter

  return (
    <div
      className={`tw-relative tw-rounded-lg tw-overflow-hidden border ${isDark ? tw-'border-slate-700 tw-bg-slate-900' : tw-'border-slate-200 bg-white'} ${className}`}
    >
      {isLoading && (
        <div className="tw-absolute tw-inset-0 tw-z-10 tw-flex tw-items-center tw-justify-center bg-white/80 tw-backdrop-blur-sm">
          <div className="tw-flex tw-items-center gap-2 tw-text-slate-500">
            <div className="h-4 w-4 tw-animate-spin tw-rounded-full tw-border-2 tw-border-blue-500 tw-border-t-transparent" />
            <span className="tw-text-sm tw-font-medium">Loading map...</span>
          </div>
        </div>
      )}

      <div
        ref={mapContainer}
        className="tw-h-full tw-w-full"
        style={{ minHeight: '400px' }}
      />

      {!isLoading && !hasMarker && (
        <div className="tw-absolute bottom-3 left-3 right-3 tw-pointer-events-none">
          <div className="tw-rounded-md bg-white/85 tw-backdrop-blur-sm px-3 py-2 text-center tw-shadow">
            <span className="tw-text-xs tw-font-medium tw-text-slate-600">Click to place pin</span>
          </div>
        </div>
      )}

      {geocodeStatus === 'loading' && (
        <div className="tw-absolute top-3 left-3">
          <div className="tw-rounded-md tw-bg-blue-50 border tw-border-blue-100 px-2 py-1 tw-shadow-sm">
            <span className="tw-text-xs tw-font-medium tw-text-blue-700">Detecting location...</span>
          </div>
        </div>
      )}

      {geocodeStatus === 'success' && hasMarker && (
        <div className="tw-absolute top-3 left-3">
          <div className="tw-rounded-md tw-bg-emerald-50 border tw-border-emerald-100 px-2 py-1 tw-shadow-sm">
            <span className="tw-text-xs tw-font-medium tw-text-emerald-700">Location detected</span>
          </div>
        </div>
      )}
    </div>
  )
}

export default MapPinSelector
